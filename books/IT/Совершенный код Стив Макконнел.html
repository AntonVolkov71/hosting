<!DOCTYPE html>

<html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8"/>
    <meta content="pandoc" name="generator"/>
    <meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
    <title>Совершенный код Стив Макконнел</title>
    <style>
        /* Default styles provided by pandoc.
        ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
        */
        html {
            color: #1a1a1a;
            background-color: #fdfdfd;
        }

        body {
            margin: 0 auto;
            max-width: 36em;
            padding-left: 50px;
            padding-right: 50px;
            padding-top: 50px;
            padding-bottom: 50px;
            hyphens: auto;
            overflow-wrap: break-word;
            text-rendering: optimizeLegibility;
            font-kerning: normal;
        }

        @media (max-width: 600px) {
            body {
                font-size: 0.9em;
                padding: 12px;
            }

            h1 {
                font-size: 1.8em;
            }
        }

        @media print {
            html {
                background-color: white;
            }

            body {
                background-color: transparent;
                color: black;
                font-size: 12pt;
            }

            p, h2, h3 {
                orphans: 3;
                widows: 3;
            }

            h2, h3, h4 {
                page-break-after: avoid;
            }
        }

        p {
            margin: 1em 0;
        }

        a {
            color: #1a1a1a;
        }

        a:visited {
            color: #1a1a1a;
        }

        img {
            max-width: 100%;
        }

        svg {
            height: auto;
            max-width: 100%;
        }

        h1, h2, h3, h4, h5, h6 {
            margin-top: 1.4em;
        }

        h5, h6 {
            font-size: 1em;
            font-style: italic;
        }

        h6 {
            font-weight: normal;
        }

        ol, ul {
            padding-left: 1.7em;
            margin-top: 1em;
        }

        li > ol, li > ul {
            margin-top: 0;
        }

        blockquote {
            margin: 1em 0 1em 1.7em;
            padding-left: 1em;
            border-left: 2px solid #e6e6e6;
            color: #606060;
        }

        code {
            font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
            font-size: 85%;
            margin: 0;
            hyphens: manual;
        }

        pre {
            margin: 1em 0;
            overflow: auto;
        }

        pre code {
            padding: 0;
            overflow: visible;
            overflow-wrap: normal;
        }

        .sourceCode {
            background-color: transparent;
            overflow: visible;
        }

        hr {
            border: none;
            border-top: 1px solid #1a1a1a;
            height: 1px;
            margin: 1em 0;
        }

        table {
            margin: 1em 0;
            border-collapse: collapse;
            width: 100%;
            overflow-x: auto;
            display: block;
            font-variant-numeric: lining-nums tabular-nums;
        }

        table caption {
            margin-bottom: 0.75em;
        }

        tbody {
            margin-top: 0.5em;
            border-top: 1px solid #1a1a1a;
            border-bottom: 1px solid #1a1a1a;
        }

        th {
            border-top: 1px solid #1a1a1a;
            padding: 0.25em 0.5em 0.25em 0.5em;
        }

        td {
            padding: 0.125em 0.5em 0.25em 0.5em;
        }

        header {
            margin-bottom: 4em;
            text-align: center;
        }

        #TOC li {
            list-style: none;
        }

        #TOC ul {
            padding-left: 1.3em;
        }

        #TOC > ul {
            padding-left: 0;
        }

        #TOC a:not(:hover) {
            text-decoration: none;
        }

        code {
            white-space: pre-wrap;
        }

        span.smallcaps {
            font-variant: small-caps;
        }

        div.columns {
            display: flex;
            gap: min(4vw, 1.5em);
        }

        div.column {
            flex: auto;
            overflow-x: auto;
        }

        div.hanging-indent {
            margin-left: 1.5em;
            text-indent: -1.5em;
        }

        /* The extra [class] is a hack that increases specificity enough to
           override a similar rule in reveal.js */
        ul.task-list[class] {
            list-style: none;
        }

        ul.task-list li input[type="checkbox"] {
            font-size: inherit;
            width: 0.8em;
            margin: 0 0.8em 0.2em -1.6em;
            vertical-align: middle;
        }

        .display.math {
            display: block;
            text-align: center;
            margin: 0.5rem auto;
        }

        #scrollTopBtn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 9999;
            padding: 10px 14px;
            font-size: 18px;
            border-radius: 8px;
            border: none;
            background: #1a1a1a;
            color: #fff;
            cursor: pointer;
            opacity: 0.6;
        }

        #scrollTopBtn:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
<header id="title-block-header">
    <h1 id="стив-макконнелл-совершенный-код">Совершенный код</h1>
    <p>Стив Макконнелл</p>
</header>

<nav id="TOC"><h2>Оглавление</h2>
    <ul>
        <li><a href="#метафоры">Метафоры</a></li>
        <li><a href="#предварительные-условия">Предварительные условия</a>
            <ul>
                <li><a href="#предварительные-условия---определение-проблемы">Предварительные
                    условия - Определение проблемы</a></li>
                <li><a href="#предварительные-условия---выработка-требований">Предварительные
                    условия - Выработка требований</a>
                    <ul>
                        <li><a href="#контрольный-список-требования">Контрольный список:
                            требования</a></li>
                    </ul>
                </li>
                <li><a href="#предварительные-условия---проектирование-архитектуры">Предварительные
                    условия - Проектирование архитектуры</a></li>
                <li><a href="#контрольный-список-архитектуры">Контрольный список
                    архитектуры</a></li>
            </ul>
        </li>
        <li><a href="#языки-программирования">Языки программирования</a>
            <ul>
                <li><a href="#контрольный-список-основные-методики-конструирования">Контрольный
                    список: основные методики конструирования</a></li>
            </ul>
        </li>
        <li><a href="#проектирование-при-конструировании">Проектирование при
            конструировании</a>
            <ul>
                <li><a href="#желательные-характеристики-проекта">Желательные характеристики
                    проекта</a></li>
                <li><a href="#уровни-проектирования">Уровни проектирования</a></li>
                <li><a href="#эвристические-принципы">Эвристические принципы</a></li>
                <li><a href="#области-вероятных-изменений">Области вероятных изменений</a></li>
                <li><a href="#паттерны-шаблоны-проектирования">Паттерны, шаблоны
                    проектирования</a></li>
                <li><a href="#методики-проектирования">Методики проектирования</a></li>
                <li><a href="#экспериментальное-прототипирование">Экспериментальное
                    прототипирование</a></li>
                <li><a href="#регистрация-процесса-проектирования">Регистрация процесса
                    проектирования</a></li>
            </ul>
        </li>
        <li><a href="#классы">Классы</a>
            <ul>
                <li><a href="#интерфейсы-классов">Интерфейсы классов</a></li>
                <li><a href="#наследование">Наследование</a></li>
                <li><a href="#классы-которые-следует-избегать">Классы, которые следует
                    избегать</a></li>
            </ul>
        </li>
        <li><a href="#высококачественные-методы">Высококачественные методы</a>
            <ul>
                <li><a href="#имена-методов">Имена методов</a></li>
                <li><a href="#объем-метода">Объем метода</a></li>
            </ul>
        </li>
        <li><a href="#параметры-методов">Параметры методов</a>
            <ul>
                <li><a href="#параметры-методов-1">Параметры методов</a></li>
                <li><a href="#функция-процедуры">Функция, процедуры</a></li>
                <li><a href="#возврат-значений-из-функции">Возврат значений из функции</a></li>
                <li><a href="#макросы">Макросы</a></li>
                <li><a href="#встраиваемые-методы">Встраиваемые методы</a></li>
                <li><a href="#защитное-программирование">Защитное программирование</a></li>
                <li><a href="#способы-обработки-ошибок">Способы обработки ошибок</a></li>
                <li><a href="#исключения">Исключения</a></li>
                <li><a href="#наступательное-программирование">Наступательное
                    программирование</a></li>
            </ul>
        </li>
        <li><a href="#псевдокод">Псевдокод</a>
            <ul>
                <li><a href="#псевдонотация">ПсевдоНотация</a></li>
                <li><a href="#конструирование-методов-с-ппп">Конструирование методов с
                    ППП</a>
                    <ul>
                        <li><a href="#проектирование-метода">Проектирование метода</a></li>
                        <li><a href="#кодирование-метода">Кодирование метода</a></li>
                        <li><a href="#проверка-кода">Проверка кода</a></li>
                        <li><a href="#наведение-глянца">Наведение глянца</a></li>
                    </ul>
                </li>
                <li><a href="#альтернативы-ппп">Альтернативы ППП</a></li>
            </ul>
        </li>
        <li><a href="#переменные">Переменные</a>
            <ul>
                <li><a href="#персистентность">Персистентность</a></li>
                <li><a href="#время-связывания">Время связывания</a></li>
                <li><a href="#связь-между-типами-данных-и-управляющими-структурами">Связь
                    между типами данных и управляющими структурами</a></li>
                <li><a href="#конвекции-именования">Конвекции именования</a></li>
                <li><a href="#область-видимости">Область видимости</a></li>
                <li><a href="#сокращение-имен">Сокращение имен</a></li>
                <li><a href="#основные-типы-данных">Основные типы данных</a></li>
                <li><a href="#целые-числа">Целые числа</a></li>
                <li><a href="#числа-с-плавающей-точкой">Числа с плавающей точкой</a></li>
                <li><a href="#символы-и-строки">Символы и строки</a></li>
                <li><a href="#логические-переменные">Логические переменные</a></li>
                <li><a href="#перечисляемые-типы">Перечисляемые типы</a></li>
                <li><a href="#именнованные-константы">Именнованные константы</a></li>
                <li><a href="#массивы">Массивы</a></li>
                <li><a href="#собственные-типы">Собственные типы</a></li>
                <li><a href="#нестандартные-типы-данных">Нестандартные типы данных</a></li>
                <li><a href="#указатели">Указатели</a></li>
                <li><a href="#глобальные-переменные">Глобальные переменные</a></li>
                <li><a href="#методы-доступа">Методы доступа</a></li>
            </ul>
        </li>
        <li><a href="#операторы">Операторы</a>
            <ul>
                <li><a href="#организация-наследовательного-кода">Организация
                    наследовательного кода</a>
                    <ul>
                        <li><a href="#подгонка-значению-ключа">Подгонка значению ключа</a></li>
                    </ul>
                </li>
                <li><a href="#таблицы-с-индексированным-доступом">Таблицы с индексированным
                    доступом</a></li>
            </ul>
        </li>
    </ul>
</nav>
<h2 id="метафоры">Метафоры</h2>
<ul>
    <li>метафора не говорит, где найти ответ, она говорит как его найти</li>
    <li>алгоритм - дает четкую последовательность команд</li>
    <li>эвристика - метод, помогающий искать ответ
        <ul>
            <li>только способ поиска, не говорит, что искать</li>
        </ul>
    </li>
    <li>знание общего подхода к проблеме, ценнее, чем знание точных
        решений
    </li>
    <li>оригинальный подход к написанию кода, часто оказывается хуже, чем
        повторное использование идей и тестов их предыдущих проектов
    </li>
    <li>инкрементная разработка - сначала простая версия системы, потом
        наращивание
        <ul>
            <li>метафора Жемчужины - процесс формирования жемчужин за счет
                приращения небольших объемов карбоната кальция
            </li>
        </ul>
    </li>
    <li>строительная метафора - Лучшее для разработки
        <ul>
            <li>тип здания - определение проблемы,</li>
            <li>план - архитектура, подробные чертежи,</li>
            <li>строители - детальное проектирование,</li>
            <li>готовка стройплощадки + фундамент + каркас - конструирование ПО</li>
            <li>дизайнеры, маляры, декораторы - оптимизация ПО</li>
            <li>инспекторы, проверка - инспекция ПО</li>
            <li>невыгодно делать самому ПО, что можно купить - взять готовый кусок
                кода, библиотеки
            </li>
            <li>Проект -&gt; Спецификация требований -&gt; Проектная
                документация
            </li>
        </ul>
    </li>
</ul>
<h2 id="предварительные-условия">Предварительные условия</h2>
<ul>
    <li>подходы
        <ul>
            <li>Итеративный
                <ul>
                    <li>активное взаимодействие с кодом</li>
                    <li>изменения вносятся сразу + проверки</li>
                    <li>чаще используется решения по коду</li>
                </ul>
            </li>
            <li>Последовательный (предварительный)</li>
            <li>сначала планируем, потом пишем</li>
            <li>можно избежать избыточно больше проблем</li>
        </ul>
    </li>
</ul>
<blockquote>
    <p>Определение проблемы -&gt; Выработка требований -&gt; Проектирование
        архитектуры -&gt; Конструирование -&gt; Тестирование</p>
</blockquote>
<h3 id="предварительные-условия---определение-проблемы">Предварительные
    условия - Определение проблемы</h3>
<ul>
    <li>без намека на решение
        <ul>
            <li>хорошо - наша система не справляется с обработкой заказа</li>
            <li>плохо - мы должны оптимизировать модули, чтобы он справлялся с
                обработкой заказа
                <ul>
                    <li>это уже не проблема, а решение</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>определение проблемы не нужно выражать компьютерными терминами
        <ul>
            <li>лучше как можно больше общими</li>
        </ul>
    </li>
    <li>неудачное определение проблемы приведет к решению не той
        проблемы
    </li>
</ul>
<h3 id="предварительные-условия---выработка-требований">Предварительные
    условия - Выработка требований</h3>
<ul>
    <li>это -
        <ul>
            <li>разработка требований</li>
            <li>анализ требований</li>
            <li>спецификация</li>
        </ul>
    </li>
    <li>требования определяются Пользователем</li>
    <li>лучше исправить строку кода, чем ошибку в требованиях</li>
    <li>при изменении требований при уже написанном коде, изменяется не
        только код, но и тесты
    </li>
    <li>выявленные ошибки в требованиях на этапе Выработки втрое дешевле,
        чем на этапе Кодирования
    </li>
    <li>Жесткое следование требованиям == не реагировать на потребности
        клиента
        <ul>
            <li>клиент всегда будет вносить изменения по ходу разработки, таковы
                реалия
            </li>
        </ul>
    </li>
    <li>четко фиксировать требования</li>
    <li>задать процедуру изменений -&gt; смета/ график</li>
    <li>можно использовать метод - Эволюционная поставка прототипирования
        <ul>
            <li>сделать отдельную подсистему, ее корректировать и потом вносить</li>
            <li>такой подход дает изменять текущую систему, не меняя его при
                добавлении изменений
            </li>
        </ul>
    </li>
    <li>не бояться оставить проект - если неудачные требования</li>
    <li>оценивать требования, которые казались прекрасными идеями, но могут
        оказаться плохими
    </li>
</ul>
<h4 id="контрольный-список-требования">Контрольный список:
    требования</h4>
<ul>
    <li>Специфические функциональные требования
        <ul>
            <li>Определены ли все способы ввода данных в систему с указанием
                источника, точности, диапазона значений и частоты ввода?
            </li>
            <li>Определены ли все способы вывода данных системой с указанием
                назначения, точности, диапазона значений, частоты и формата?
            </li>
            <li>Определены ли все форматы вывода для Web-страниц, отчетов и т.
                д.?
            </li>
            <li>Определены ли все внешние аппаратные и программные интерфейсы?</li>
            <li>Определены ли все внешние коммуникационные интерфейсы с указанием
                протоколов установления соединения, проверки ошибок и коммуникации?
            </li>
            <li>Определены ли все задачи, в выполнении которых нуждается
                пользователь?
            </li>
            <li>Определены ли данные, используемые в каждой задаче, и данные,
                являющиеся результатом выполнения каждой задачи?
            </li>
        </ul>
    </li>
    <li>Специфические нефункциональные требования (требования к качеству)
        <ul>
            <li>Определено ли ожидаемое пользователем время реакции для всех
                необходимых операций?
            </li>
            <li>Определены ли другие временные параметры, такие как время обработки
                данных, скорость их передачи и пропускная способность системы?
            </li>
            <li>Определен ли уровень защищенности системы?</li>
            <li>Определена ли надежность системы, в том числе такие аспекты, как
                следствия сбоев в ее работе, информация,
                <ul>
                    <li>которая должна быть защищена от сбоев, и стратегия обнаружения и
                        исправления ошибок?
                    </li>
                </ul>
            </li>
            <li>Определены ли минимальные требования программы к объему памяти и
                свободного дискового пространства?
            </li>
            <li>Определены ли аспекты удобства сопровождения системы, в том числе
                способность системы адаптироваться к изменениям специфических функций,
                ОС и интерфейсов с другими приложениями?
            </li>
            <li>Включено ли в требования определение успеха? Или неудачи?</li>
        </ul>
    </li>
    <li>Качество требований
        <ul>
            <li>Написаны ли требования на языке, понятном пользователям? Согласны ли
                с этим пользователи?
            </li>
            <li>Нет ли конфликтов между требованиями?</li>
            <li>Определено ли приемлемое равновесие между параметрами-антагонистами,
                <ul>
                    <li>такими как устойчивость к нарушению исходных предпосылок и
                        корректность?
                    </li>
                </ul>
            </li>
            <li>Не присутствуют ли в требованиях элементы проектирования?</li>
            <li>Согласован ли уровень детальности требований?
                <ul>
                    <li>Следует ли какое-нибудь требование определить подробнее?</li>
                    <li>Менее подробно?</li>
                </ul>
            </li>
            <li>Достаточно ли ясны и понятны требования, чтобы их можно было
                передать независимой группе конструирования?
                <ul>
                    <li>Согласны ли с этим разработчики?</li>
                </ul>
            </li>
            <li>Каждое ли требование релевантно для проблемы и ее решения?
                <ul>
                    <li>Можно ли проследить каждое требование до его источника в проблемной
                        среде?
                    </li>
                </ul>
            </li>
            <li>Можно ли протестировать каждое требование?
                <ul>
                    <li>Можно ли будет провести независимое тестирование, которое позволит
                        сказать, выполнены ли все требования?
                    </li>
                </ul>
            </li>
            <li>Определены ли все возможные изменения требований и вероятность
                каждого изменения?
            </li>
        </ul>
    </li>
    <li>Полнота требований
        <ul>
            <li>Указаны ли недостающие требования, которые невозможно определить до
                начала разработки?
            </li>
            <li>Полны ли требования в том смысле, что если приложение будет
                удовлетворять всем требованиям, то оно будет приемлемо?
            </li>
            <li>Не вызывают ли какие-нибудь требования у вас дискомфорта?
                <ul>
                    <li>Исключили ли вы требования, которые не поддаются реал</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="предварительные-условия---проектирование-архитектуры">Предварительные
    условия - Проектирование архитектуры</h3>
<ul>
    <li>время исправления ошибок в архитектуре == времени исправления
        требований, т.е. превышает затраты на исправление ошибок в коде
    </li>
    <li>основные аспекты:
        <ul>
            <li>организация программы:
                <ul>
                    <li>определение основных компонентов (отдельные классы или
                        подсистемы)
                    </li>
                    <li>определение ответственности каждого компонента
                        <ul>
                            <li>одна область ответственности и меньше знать о других</li>
                            <li>слабая связанность</li>
                        </ul>
                    </li>
                    <li>определение правила коммуникации для каждого компонента (кто, как и
                        кого использует)
                    </li>
                </ul>
            </li>
            <li>основные классы:
                <ul>
                    <li>определение основных классов, их обязательные ответственности и
                        механизмы взаимодействия
                    </li>
                    <li>иерархия классов, подсистем</li>
                    <li>правило 80/20
                        <ul>
                            <li>20 - описывается</li>
                            <li>80 - определяется в поведении</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>организация данных:
                <ul>
                    <li>определение основных видов файлов, таблиц</li>
                    <li>прямой доступ к данным обычно только одной системе или классу</li>
                    <li>определение высокоуровневой организации и всех использований БД и
                        почему именно эта БД
                    </li>
                </ul>
            </li>
            <li>бизнес правила:
                <ul>
                    <li>определение бизнес-правил, описание их влияние на проект</li>
                </ul>
            </li>
            <li>пользовательский интерфейс:
                <ul>
                    <li>обязательно проектируется на этапе Выработки требований</li>
                    <li>описание главных элементов Web, GUI, интерфейса командной
                        строки
                    </li>
                    <li>архитектура должна быть модульной, дабы изменять GUI не затрагивая
                        бизнес-правила и модули программы
                    </li>
                </ul>
            </li>
            <li>управление ресурсами:
                <ul>
                    <li>соединение с БД, потоки</li>
                    <li>драйвера</li>
                    <li>управление памятью</li>
                    <li>оценка ресурсов при номинальной и экстремальной нагрузке</li>
                </ul>
            </li>
            <li>безопасность:
                <ul>
                    <li>отработка буферов, ненадежных данных</li>
                    <li>подход к шифрованию</li>
                    <li>ошибки</li>
                    <li>обработка секретных данных</li>
                </ul>
            </li>
            <li>производительность:
                <ul>
                    <li>приоритеты ресурсов
                        <ul>
                            <li>быстродействие -&gt; память или скорость</li>
                        </ul>
                    </li>
                    <li>объяснение показателей, выбор алгоритмов</li>
                </ul>
            </li>
            <li>масштабируемость:
                <ul>
                    <li>адаптация к росту требований</li>
                </ul>
            </li>
            <li>взаимодействие с другими системами:
                <ul>
                    <li>показать реализацию к другим ПО, программным системам</li>
                </ul>
            </li>
            <li>интернационализация(i18n):
                <ul>
                    <li>не только перевод</li>
                    <li>а выбор набора символов (ASCII, Unicode)</li>
                </ul>
            </li>
            <li>ввод/вывод:
                <ul>
                    <li>схема чтения данных, по требованию (задержка)</li>
                    <li>определение ошибок ввода
                        <ul>
                            <li>на уровне полей, записей, потоков данных или файлов</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>обработка ошибок:
                <ul>
                    <li>90% кода - блоки обработки исключений</li>
                    <li>обработка ошибок:
                        <ul>
                            <li>корректирующие - восстановление работы от последствий ошибок</li>
                            <li>ориентированные - все равно на ошибку</li>
                        </ul>
                    </li>
                    <li>обнаружение:
                        <ul>
                            <li>активное - сразу проверять корректность</li>
                            <li>пассивное - реагировать когда уже, что-то случилось</li>
                        </ul>
                    </li>
                    <li>соглашения об ошибках
                        <ul>
                            <li>интерфейс ошибок определить сразу</li>
                        </ul>
                    </li>
                    <li>определение когда генерить исключения
                        <ul>
                            <li>их перехват, логирование</li>
                        </ul>
                    </li>
                    <li>определение уровня обработки ошибок (внутри или возвращение по
                        цепочке вызова)
                    </li>
                    <li>механизм обработки
                        <ul>
                            <li>кастомный - лучший вариант</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>отказоустойчивость:
                <ul>
                    <li>возврат системы в предыдущее состояние после сбоя</li>
                    <li>алгоритм голосования - отказ или нет</li>
                    <li>замена ошибочного значения поддельным в одном модуле, чтобы система
                        продолжала работать
                    </li>
                </ul>
            </li>
            <li>возможность организации архитектуры:
                <ul>
                    <li>подтверждение того, что выполнение архитектуры технически
                        осуществимо
                    </li>
                </ul>
            </li>
            <li>избыточная функциональность:
                <ul>
                    <li>определить какие классы (подсистемы) должны быть исключительно
                        надежны, а другие лишь отвечают требованиям
                    </li>
                </ul>
            </li>
            <li>готовая и собственная реализация библиотек:
                <ul>
                    <li>если готовая, она лучше</li>
                    <li>если нужно собственную, определить, что сами реализуем, что
                        используем готовое
                    </li>
                    <li>объяснение повторно используемым ресурсов</li>
                </ul>
            </li>
            <li>стратегия изменений:
                <ul>
                    <li>резерв полей на будущее</li>
                </ul>
            </li>
            <li>общее количество архитектуры:
                <ul>
                    <li>обоснование целей, принятых решений</li>
                    <li>спецификация описываемых классов, информативно, но не как
                        конституция
                    </li>
                    <li>архитектура не должна зависеть от платформы ни от языка
                        <ul>
                            <li>только если она ориентированна на конкретные языки или
                                платформы
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="контрольный-список-архитектуры">Контрольный список
    архитектуры</h3>
<ul>
    <li>Специфические аспекты архитектуры
        <ul>
            <li>Ясно ли описана общая организация программы? Включает ли
                спецификация грамотный обзор архитектуры и ее обоснование?
            </li>
            <li>Адекватно ли определены основные компоненты программы, их области
                ответственности и взаимодействие с другими компонентами?
            </li>
            <li>Все ли функции, указанные в спецификации требований, реализуются
                разумным, не слишком большим и не слишком малым, числом
                компонентов?
            </li>
            <li>Приведено ли описание самых важных классов и их обоснование?</li>
            <li>Приведено ли описание организации данных и ее обоснование?</li>
            <li>Приведено ли описание организации и содержания БД?</li>
            <li>Определены ли все важные бизнес-правила? Описано ли их влияние на
                систему?
            </li>
            <li>Описана ли стратегия проектирования GUI?</li>
            <li>Сделан ли GUI модульным, чтобы его изменения не влияли на оставшуюся
                часть программы?
            </li>
            <li>Приведено ли описание стратегии ввода-вывода данных и ее
                обоснование?
            </li>
            <li>Указаны ли оценки степени использования ограниченных ресурсов:
                <ul>
                    <li>потоки, соединения с БД, дескрипторы, пропускная способность
                        сети?
                    </li>
                    <li>Приведено ли описание стратегии управления такими ресурсами и ее
                        обоснование?
                    </li>
                </ul>
            </li>
            <li>Описаны ли требования к защищенности архитектуры?</li>
            <li>Определяет ли архитектура требования к объему и быстродействию всех
                классов, подсистем и функциональных областей?
            </li>
            <li>Описывает ли архитектура способ достижения масштабируемости
                системы?
            </li>
            <li>Рассмотрены ли вопросы взаимодействия системы с другими
                системами?
            </li>
            <li>Описана ли стратегия интернационализации/локализации?</li>
            <li>Определена ли согласованная стратегия обработки ошибок?</li>
            <li>Определен ли подход к отказоустойчивости системы (если это
                требуется)?
            </li>
            <li>Подтверждена ли возможность технической реализации всех частей
                системы?
            </li>
            <li>Определен ли подход к реализации избыточной функциональности?</li>
            <li>Приняты ли необходимые решения относительно «покупки или создания»
                компонентов системы?
            </li>
            <li>Описано ли в спецификации, как повторно используемый код будет
                адаптирован к другим аспектам архитектуры?
            </li>
            <li>Сможет ли архитектура адаптироваться к вероятным изменениям?</li>
        </ul>
    </li>
    <li>Общее качество архитектуры
        <ul>
            <li>Все ли требования отражены в архитектуре?</li>
            <li>Является ли какая-нибудь часть системы чрезмерно или недостаточно
                проработанной? Заданы ли явные ожидания по этому поводу?
            </li>
            <li>Является ли вся архитектура концептуально целостной?</li>
            <li>Независим ли высокоуровневый проект системы от платформы и языка,
                который будет использован для его реализации?
            </li>
            <li>Указаны ли мотивы принятия всех основных решений?</li>
            <li>Удовлетворяет ли вас — программиста, который будет реализовывать
                систему, — разработанная архитектура?
            </li>
        </ul>
    </li>
</ul>
<h2 id="языки-программирования">Языки программирования</h2>
<ul>
    <li>программирование на языке ограничена мышлением конструкциями языка и
        примитивна
    </li>
    <li>программирование с использованием языка сначала решают мысли,
        которые хотят выразить, после определяют как их выразить
    </li>
</ul>
<h3 id="контрольный-список-основные-методики-конструирования">Контрольный
    список: основные методики конструирования</h3>
<ul>
    <li>Кодирование
        <ul>
            <li>Решили ли вы, какая часть проекта приложения будет разработана
                предварительно, а какая во время написания кода?
            </li>
            <li>Выбрали ли вы конвенции именования программных элементов, оформления
                комментариев и форматирования кода?
            </li>
            <li>Выбрали ли вы специфические методики кодирования, определяемые
                архитектурой приложения?
                <ul>
                    <li>Определили ли вы, как будут обрабатываться ошибки, как будут
                        решаться проблемы,
                        <ul>
                            <li>связанные с безопасностью, какие конвенции будут использоваться при
                                разработке интерфейсов классов,
                            </li>
                            <li>каким стандартам должен будет отвечать повторно используемый
                                код,
                            </li>
                            <li>сколько внимания нужно будет уделять быстродействию приложения при
                                кодировании и т. д.?
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>Определили ли вы стадию развития используемой технологии и
                адаптировали ли к ней свой подход?
                <ul>
                    <li>Если это необходимо, определились ли вы с тем, как будете
                        программировать с использованием языка,
                        <ul>
                            <li>вместо того чтобы ограничиваться программированием на нем?</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Работа в группе
        <ul>
            <li>Определили ли вы процедуру интеграции?
                <ul>
                    <li>Иначе говоря, какие специфические действия программист должен будет
                        выполнить перед включением своего кода в исходный код всего
                        проекта?
                    </li>
                </ul>
            </li>
            <li>Будут ли программисты программировать парами, индивидуально или эти
                подходы будут скомбинированы?
            </li>
        </ul>
    </li>
    <li>Гарантия качества
        <ul>
            <li>Должны ли будут программисты разработать тесты для своего кода до
                написания самого кода?
            </li>
            <li>Должны ли будут программисты разработать блочные тесты для своего
                кода?
            </li>
            <li>Должны ли будут программисты перед включением своего кода в исходный
                код всего проекта проанализировать его в отладчике?
            </li>
            <li>Должны ли будут программисты выполнить интеграционное тестирование
                своего кода до его включения в исходный код проекта?
            </li>
            <li>Будут ли программисты выполнять взаимные обзоры или инспекцию
                кода?
            </li>
        </ul>
    </li>
    <li>Инструменты
        <ul>
            <li>Выбрали ли вы инструмент управления версиями?</li>
            <li>Выбрали ли вы язык, версию языка и версию компилятора?</li>
            <li>Выбрали ли вы платформу программирования (такую как J2EE или
                Microsoft .NET) или явно решили не использовать ее?
            </li>
            <li>Приняли ли вы решение о том, можно ли будет использовать
                нестандартные возможности языка?
            </li>
            <li>Определили ли вы другие средства, которые будете применять:
                редактор, инструмент рефакторинга, платформу для тестирования
            </li>
        </ul>
    </li>
</ul>
<h2 id="проектирование-при-конструировании">Проектирование при
    конструировании</h2>
<ul>
    <li>это есть разработка или изобретение схемы преобразования
        спецификации приложения в готовое приложение
    </li>
    <li>это процесс, который связывает выработку требований с кодированием и
        отладкой
    </li>
</ul>
<blockquote>
    <p>Работая над проблемой, я никогда не думаю о красоте. Я думаю только о
        решении проблемы Но если решение получилось некрасивое, я знаю, что оно
        не верно</p>
</blockquote>
<h3 id="желательные-характеристики-проекта">Желательные характеристики
    проекта</h3>
<ul>
    <li>минимальная сложность</li>
    <li>простота сопровождения</li>
    <li>слабое сопряжение:
        <ul>
            <li>сведение к минимальному числу соединений между частями
                программы
            </li>
            <li>используется принцип ООП для ухода от связности и зависимости</li>
        </ul>
    </li>
    <li>расширяемость:
        <ul>
            <li>улучшение системы, не нарушая ее основной структуры</li>
        </ul>
    </li>
    <li>повторное использование</li>
    <li>обязательно ‘fan-in’ и ‘fan-out’
        <ul>
            <li>fan-in
                <ul>
                    <li>высокий коэффициент объединения по входу</li>
                    <li>к конкретному классу обращается большое число других классов</li>
                    <li>интенсивное использование вспомогательных низкоуровневых
                        классов
                    </li>
                </ul>
            </li>
            <li>fan-out
                <ul>
                    <li>низкий или средний коэффициент разветвления по выходу</li>
                    <li>конкретный класс обращается к малому или среднему числу других
                        классов
                    </li>
                    <li>больше 7 - это уже высокий fan-out - усложняет систему</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>минимальная, но полная функциональность &gt; ПО закончено не тогда,
        когда в нее больше нечего добавить, а когда из него ничего нельзя
        выбросить
    </li>
    <li>стратификация
        <ul>
            <li>разделение уровней декомпозиции</li>
            <li>так, чтобы можно изучать отдельные уровни, игнорируя другие</li>
        </ul>
    </li>
</ul>
<h3 id="уровни-проектирования">Уровни проектирования</h3>
<ul>
    <li>1 уровень - Программная система
        <ul>
            <li>обдумать более высокоуровневые комбинации классов, такие как
                подсистемы, пакеты
            </li>
            <li>думать выше классов</li>
        </ul>
    </li>
    <li>2 уровень - Разделение системы на подсистемы, пакеты
        <ul>
            <li>разделить систему на основные подсистемы
                <ul>
                    <li>модуль БД</li>
                    <li>модуль GUI</li>
                </ul>
            </li>
            <li>определение правил взаимодействия подсистем</li>
            <li>!избегать циклических отношений между системами</li>
        </ul>
    </li>
    <li>3 уровень - Разделение пакетов на классы
        <ul>
            <li>разделить подсистемы на классы
                <ul>
                    <li>пример, БД доступ к данным, и классы хранения данных</li>
                </ul>
            </li>
            <li>интерфейсы классов</li>
            <li>декомпозиция подсистем до уровня детальности, который позволит
                реализовать части систем в форме отдельных классов
            </li>
            <li>различие классов и объекта
                <ul>
                    <li>класс - схема</li>
                    <li>объект - экземпляр</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>4 уровень - Разделение классов на данные и методы
        <ul>
            <li>основные уже в 3 уровне</li>
            <li>здесь приватные</li>
            <li>уже можно оставить программисту дял реализации, т.к. интерфейс
                определен на 3 уровне
            </li>
        </ul>
    </li>
    <li>5 уровень - Проектирование методов
        <ul>
            <li>в целом отвечает программист, но можно определить
                <ul>
                    <li>псевдокод</li>
                    <li>алгоритмы</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="эвристические-принципы">Эвристические принципы</h3>
<ul>
    <li>следует знать, что не система выполняет, а над чем она
        выполняет
    </li>
    <li>подходы в проектировании
        <ul>
            <li>общепринятые ООП
                <ul>
                    <li>объекты и их атрибуты, действие над каждым объектом, действие над
                        другими
                    </li>
                    <li>сначала определить данные и потом конкретные действия над ними</li>
                </ul>
            </li>
            <li>определение частей объекта, видимые другим</li>
        </ul>
    </li>
    <li>абстракции, скрывающие внутренние механизмы классов
        <ul>
            <li>основная идея борьбы со сложностью реального мира
                <ul>
                    <li>пример, абстракция двери - просто прямоугольный фрагмент некоторого
                        материала, ручек и петель
                        <ul>
                            <li>если все равно какая древесина, молекулы и т.д.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>инкапсуляция деталей реализации
        <ul>
            <li>мы можем смотреть на дом, но не можем подойти ближе, чтобы узнать из
                чего дверь
            </li>
            <li>инкапсуляция дает знать о существовании двери, открыта/закрыта, но
                не из чего
            </li>
        </ul>
    </li>
    <li>наследование
        <ul>
            <li>определение сходств и различий между объектами
                <ul>
                    <li>пример, мальчики и девочки, оба человек - есть наследование</li>
                    <li>для дверей могут быть общие open/close</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>отсутствие информации о конкретном типе объекта, вплоть до периода
        выполнения - есть Полиморфизм
    </li>
    <li>интерфейс классов
        <ul>
            <li>нужен если класс может изменяться или другая версия этого класса
                (FileLogger, ConsoleLogger)
            </li>
            <li>нет - низкоуровневый класс</li>
            <li>интерфейс - аспект проектирования класса</li>
            <li>скрываем все, что можно, наружу минимум
                <ul>
                    <li>легче модифицировать</li>
                    <li>особенно возвращаемые типы, только для пользователей, внутри другие
                        типы этого поля
                    </li>
                    <li>!! чаще задавать себе вопрос - Что мне еще скрыть</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="области-вероятных-изменений">Области вероятных изменений</h3>
<ul>
    <li>для будущих изменений, можно попытаться определить возможные части,
        которые вероятно кажутся изменяемыми
        <ul>
            <li>определить дял таких обязательно !!Интерфейсы между классами</li>
            <li>скрывать логику в одном месте, наружу только интерфейсы</li>
            <li>изоляция модулей (сервисов)</li>
        </ul>
    </li>
    <li>использовать переменную статуса вместо булевого возвращаемого
        значения (перечисления тоже можно)
    </li>
    <li>вместо жестко закодированной проверки, используемых в нескольких
        местах, перенос в одно место
    </li>
    <li>слабое сопряжение (связи между классами)
        <ul>
            <li>виды:
                <ul>
                    <li>НОРМАЛЬНО - данные параметры передаются как элементы</li>
                    <li>НОРМАЛЬНО - объект - создает экземпляры объекта</li>
                    <li>ПЛОХО - объект - параметр - объект 1 требует, чтобы Объект 2 передал
                        Объект 3
                    </li>
                    <li>ПЛОХО - семантическое
                        <ul>
                            <li>один модуль знает (сопрягается) по семантическим значениям о
                                внутренней работе этого модуля
                            </li>
                            <li>использующий объект не должен знать как устроен другой объект,
                                особенно о порядке его работы
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>стараться использовать популярные паттерны шаблонов
        проектирования
    </li>
</ul>
<h3 id="паттерны-шаблоны-проектирования">Паттерны, шаблоны
    проектирования</h3>
<ul>
    <li>Абстрактная фабрика
        <ul>
            <li>создание наборов родственных объектов путем определения вида набора,
                но не всегда каждого отдельного объекта
            </li>
        </ul>
    </li>
    <li>Адаптер
        <ul>
            <li>преобразование одного класса в другой</li>
        </ul>
    </li>
    <li>Компоновщик
        <ul>
            <li>состоит из объекта, содержащего дополнительные объекты того же типа
                (типа дерево объектов одинакового типа)
            </li>
        </ul>
    </li>
    <li>Декоратор
        <ul>
            <li>динамически добавление объекту видов ответственности без создания
                подклассов для каждого возможной конфигурации видов ответственности
            </li>
        </ul>
    </li>
    <li>Фасад
        <ul>
            <li>согласованный интерфейс к коду, которые не предоставили бы
                согласованные интерфейсы
            </li>
        </ul>
    </li>
    <li>Фабричный метод
        <ul>
            <li>создание экземпляров классов, производных от конкретного базового
                класса
            </li>
        </ul>
    </li>
    <li>Итератор
        <ul>
            <li>серверный объект предоставляющий доступ к каждому элементу набора в
                последовательном порядке
            </li>
        </ul>
    </li>
    <li>Наблюдатель
        <ul>
            <li>синхронизация нескольких объектов, при котором объект уведомляет
                набор связанных объектов об изменении любого члена набора
            </li>
        </ul>
    </li>
    <li>Одиночка
        <ul>
            <li>глобальный доступ к классу, который может иметь один и только один
                экземпляр
            </li>
        </ul>
    </li>
    <li>Стратегия
        <ul>
            <li>определенный набор динамически взаимосвязанных алгоритмов или видов
                поведения
            </li>
        </ul>
    </li>
    <li>Шаблонный метод
        <ul>
            <li>определенная структура алгоритма, оставляя детали реализации
                подклассам
            </li>
        </ul>
    </li>
</ul>
<h3 id="методики-проектирования">Методики проектирования</h3>
<ul>
    <li>Итерация в подходе разработки
        <ul>
            <li>сделал А потом В, если В лучше, вернись к А</li>
        </ul>
    </li>
    <li>Нисходящий (top-down)
        <ul>
            <li>начинаем на высоком уровне абстракции
                <ul>
                    <li>сначала базовые классы, далее повышаем уровень детализации и
                        производных классов
                    </li>
                </ul>
            </li>
            <li>сначала общие, потом декомпозиция, делим на системы
                (декомпозиция)
            </li>
        </ul>
    </li>
    <li>Восходящий (bottom-up)
        <ul>
            <li>начинаем со специфичных и постепенно переходим к все большей
                общности,
            </li>
            <li>определяем конкретные объекты, функции, а потом уже как ими
                управлять (композиция)
            </li>
        </ul>
    </li>
</ul>
<h3 id="экспериментальное-прототипирование">Экспериментальное
    прототипирование</h3>
<ul>
    <li>важно уметь делать минимальный код, для опробования какого-либо
        вопроса
    </li>
    <li>но обязательно, конкретно - не просто организация работы БД, а будут
        ли 1000 транзакций укладываться в 1 секунду при данных x, y , z
    </li>
    <li>этот минимальный код - ВЫКИДЫВАЕТСЯ,
        <ul>
            <li>так как это не реализация системы, а эксперимент</li>
        </ul>
    </li>
</ul>
<h3 id="регистрация-процесса-проектирования">Регистрация процесса
    проектирования</h3>
<ul>
    <li>облегченная методика
        <ul>
            <li>включить проектирование документации в коде
                <ul>
                    <li>например, JavaDoc</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>записывать резюме бесед (типа протокола), чтобы зафиксировать</li>
    <li>фиксирование изображений, диаграмм, рисунков</li>
</ul>
<h2 id="классы">Классы</h2>
<ul>
    <li>ATD абстрактный тип данных
        <ul>
            <li>управлять из вне лучше по методам, а не напрямую влезать
                <ul>
                    <li>выставить например Bold для шрифта, лучше у абстракции вызвать метод
                        setBold, чем напрямую установить
                        <ul>
                            <li>не нужно как выставляется внутри этот параметр</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>даже банальное class.getValue - скрывает реализацию, и позволяет
                подменить данные для пользователя
                <ul>
                    <li>здесь понятно, что Value может скрываться сложной функциональностью
                        и скрыты зависимости
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>при это ATD - реализуем как низкоуровневый тип
        <ul>
            <li>если список сотрудников, то именно и предоставляем как список
                сотрудников, а не просто список
            </li>
            <li>но при этом, например, операция запись на диск, избавляет от
                представления, что происходит (чтение головки и т.д.)
            </li>
            <li>здесь высокоуровневая абстракция с низкоуровневым типом!
                <ul>
                    <li>открыть/закрыть дверь
                        <ul>
                            <li>открыть/закрыть - высокоуровневый</li>
                            <li>дверь - низкоуровневый</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>ATD даже для простого элемента, операции
        <ul>
            <li>это дает возможность изменять код без последствий</li>
        </ul>
    </li>
    <li>так же Высокоуровневая абстракция с низкоуровневой в названии
        методов и классов
        <ul>
            <li>более абстрактные названия
                <ul>
                    <li>например, таблица рейтинга храниться в табличных файлах, не нужно
                        делать метод RateFileRead
                        <ul>
                            <li>лучше RateRead</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="интерфейсы-классов">Интерфейсы классов</h3>
<ul>
    <li>Абстракция - представление сложной операции в простой форме</li>
    <li>Интерфейс класса - абстракция реализации класса, скрытой за
        интерфейсом
    </li>
    <li>Один класс - один ATD
        <ul>
            <li>если больше разбиваем, реорганизуем
                <ul>
                    <li>пример, есть класс со списком людей
                        <ul>
                            <li>открытые методы - получить первого, перебор</li>
                        </ul>
                    </li>
                    <li>так вот если его наследовать от класса список, это некорректно, ибо
                        список людей не реализует список
                        <ul>
                            <li>тут в приватном поле будет использоваться класс список</li>
                            <li>методы какие надо будут иметь отношение к списку людей, а не к
                                списку
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>методы вместе с противоположными
        <ul>
            <li>если есть метод открыть, должен ыть закрыть
                <ul>
                    <li>но, проверь целесообразность</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>не нарушать целостность интерфейса
        <ul>
            <li>не добавлять при дальнейшей эксплуатации новые не подходящие по
                смыслу функции
            </li>
        </ul>
    </li>
    <li>Важно в интерфейсе соблюдать сильную связанность
        <ul>
            <li>класс должен выполнять и быть связан по смыслу с другими, от этого и
                интерфейс будет адекватный
            </li>
        </ul>
    </li>
    <li>Скрывать реализацию, отделяя от интерфейса
        <ul>
            <li>объявление класса включить как указатель на его реализацию, но не
                включать другие реализации &gt; Если для понимания того, что происходит
                нужно увидеть реализацию, это НЕ АБСТРАКЦИЯ
            </li>
        </ul>
    </li>
    <li>семантические нарушения
        <ul>
            <li>не совать нос во внутренние дела другого класса
                <ul>
                    <li>иногда соблазн использовать (либо наоборот не использовать) какие-то
                        функции, зная, что тот класс, который использует делать уже это
                        <ul>
                            <li>пример, не вызывать метод Initialized() класса А, потому что метод
                                класса А PerformFirstOperation вызывает его
                            </li>
                            <li>!! Не лезь внутрь того, что не открыто</li>
                        </ul>
                    </li>
                    <li>при таком реализуя пользовательский код один метод не явно зависит
                        от другого, а если другой изменить, вот и не найдешь ошибку
                    </li>
                    <li>это называется программирование сквозь интерфейс, нарушая
                        инкапсуляцию &gt; Если класс содержит более 7 элементов данных членов
                        будь осторожен
                    </li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="наследование">Наследование</h3>
<ul>
    <li>открытое наследование означает - “является”</li>
    <li>если при проектировании решили, что класс не должен поддерживать не
        объявляй его члены “virtual”
    </li>
    <li>реализовать наследование Только если
        <ul>
            <li>базовый и производные класса имеют все методы
                <ul>
                    <li>базовый класс Account (счет) и производные CheckingAccount,
                        SavingAccount
                        <ul>
                            <li>только если можно использовать Account не заботитесь о конкретном
                                подтипе счета
                            </li>
                        </ul>
                    </li>
                    <li>если производные классы начинают расходиться - Отделите их</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>подозрительно относиться к классу Одиночка</li>
    <li>подозрительно к базовым класса, имеющим Один производный класс</li>
    <li>Не делать пустой метод для переопределения
        <ul>
            <li>то есть если обнаружили, что не все производные классы должны
                реализовывать эти методы, вынесите в отдельный класс метод
                <ul>
                    <li>и используйте как интерфейс</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>избегайте многоуровневой иерархии наследования
        <ul>
            <li>есть реализация не более 6 уровней, Но это много
                <ul>
                    <li>максимум 2-3</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Используйте полиморфизм вместо проверки типов
        <ul>
            <li>иногда switch лучше заменить, но всегда
                <ul>
                    <li>пример, switch(Command()) хорошо
                        <ul>
                            <li>а switch(ShapeType) -&gt; DrawCircle (DrawSquare) - лучше поделить
                                на классы DrawClass то есть скрыть
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Делайте данные закрытыми, а не защищенными
        <ul>
            <li>при наследовании мы получаем доступ к привилегированным данным (не
                надо так)
            </li>
        </ul>
    </li>
    <li>Расширение лучше Множественного наследования</li>
</ul>
<h3 id="классы-которые-следует-избегать">Классы, которые следует
    избегать</h3>
<ul>
    <li>если класс не содержит изменений формирующих поведения</li>
    <li>названия классов содержат глаголы</li>
</ul>
<h2 id="высококачественные-методы">Высококачественные методы</h2>
<ul>
    <li>метод - отдельная функция, процедура, выполняющая Одну Задачу</li>
    <li>связность
        <ul>
            <li>функциональная
                <ul>
                    <li>самая сильная и лучшая, метод выполняет одну и только одну операцию
                        <ul>
                            <li>удалить файл, определить возраст и т.д.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>менее эффективные:
                <ul>
                    <li>последовательная
                        <ul>
                            <li>когда метод содержит операции, которые выполняются в определенном
                                порядке
                            </li>
                            <li>используется результат предыдущего этапа
                                <ul>
                                    <li>пример, метод, вычисляем по ДР возраст и срок его ухода на пенсию
                                        <ul>
                                            <li>это и есть последовательная связность</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>коммуникационная
                        <ul>
                            <li>используются данные не связанные между собой</li>
                        </ul>
                    </li>
                    <li>временная
                        <ul>
                            <li>объединение операций, потом что они выполняются в один интервал
                                времени
                                <ul>
                                    <li>но иногда используется, если нужна согласованность действий, а не их
                                        выполнения
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>процедурная (СТАРАТЬСЯ НЕ ИСПОЛЬЗОВАТЬ)
                        <ul>
                            <li>выполняет операции в определенном порядке</li>
                            <li>лучше вынести ив отдельный метод</li>
                        </ul>
                    </li>
                    <li>логическая (СТАРАТЬСЯ НЕ ИСПОЛЬЗОВАТЬ)
                        <ul>
                            <li>набор выполняемых операций по управляющему флагу
                                <ul>
                                    <li>ряд is, case</li>
                                </ul>
                            </li>
                            <li>только если это не обработчик событий &gt; Стремиться создавать
                                методы с функциональной связностью
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="имена-методов">Имена методов</h3>
<ul>
    <li>не абстрактные и не слишком длинные</li>
    <li>избегать невыразительных неоднозначных глаголов
        <ul>
            <li>вместо HandleOutput -&gt; ForwardAndPrint</li>
        </ul>
    </li>
    <li>для именования используем описание возвращаемого значения</li>
    <li>использовать антонимы</li>
</ul>
<pre><code>add/remove      increment/decrement      open/close
begin/end       insert/delete            show/hide
create/destroy  lock/unlock              source/target
first/last      min/max                  start/stop
get/put         next/previous            up/down
get/set         old/new</code></pre>
<ul>
    <li>определить одну конвенцию часто используемых для классов, методов,
        переменных
    </li>
</ul>
<h3 id="объем-метода">Объем метода</h3>
<ul>
    <li>200 строк - один метод</li>
</ul>
<h2 id="параметры-методов">Параметры методов</h2>
<ul>
    <li>порядок передачи параметров:
        <ul>
            <li>входные значения</li>
            <li>изменяемые параметры</li>
            <li>выходные параметры</li>
        </ul>
    </li>
    <li>ключевые слова IN/OUT, вход/выход
        <ul>
            <li>в С++ их нет, но можно макросами</li>
        </ul>
    </li>
</ul>
<h3 id="параметры-методов-1">Параметры методов</h3>
<ul>
    <li><p>порядок передачи параметров</p>
        <ul>
            <li>входные значения</li>
            <li>изменяемые параметры</li>
            <li>выходные значения</li>
        </ul>
    </li>
    <li><p>ключевые слова IN/OUT - входные/выходные</p>
        <pre><code>    #define IN
    #define OUT

    void InvertMatrix(IN Matrix originalMatrix, OUT Matrix resultMatrix);</code></pre>
        <ul>
            <li>IN/OUT просто для документации, в коде ничего не значат, аналог
                const
            </li>
        </ul>
    </li>
    <li><p>переменные статуса или коды ошибок</p>
        <ul>
            <li>передаются последними</li>
            <li>это выходные параметры</li>
        </ul>
    </li>
    <li><p>не используйте в качестве рабочих переменных параметры
        метода!!</p></li>
</ul>
<pre><code>int Sample(int inputValue){
    inputValue = someData // Это уже не входной параметр
}</code></pre>
<ul>
    <li>число передаваемых параметров максимум 7 !!
        <ul>
            <li>если больше сгруппировать в класс</li>
        </ul>
    </li>
    <li>определить Конвенцию именования входных, изменяемых, выходных
        <ul>
            <li>i_, m_, o_ - Плохо</li>
            <li>Input_, Modify_, Output_ - Лучше</li>
        </ul>
    </li>
    <li>если при передаче класса (объекта) передавать только те переменные,
        поля которых нужны методу
        <ul>
            <li>но!! при этом если из класса параметра вытащить только нужные для
                этого метода, связность уменьшится,
            </li>
            <li>тогда инкапсуляция этих элементов и их связность пропадет</li>
            <li>!! если нужны только некоторые переменные из класса, Передаем весь
                класс
            </li>
        </ul>
    </li>
</ul>
<h3 id="функция-процедуры">Функция, процедуры</h3>
<ul>
    <li>Функция - этот метод возвращающий значение</li>
    <li>Процедура - значение не возвращает</li>
    <li>часто Функция как процедура, но возвращает код статуса</li>
</ul>
<h3 id="возврат-значений-из-функции">Возврат значений из функции</h3>
<ul>
    <li>используем значение по умолчанию для некорректного возвращения</li>
    <li>Не возвращать Ссылки/Указатели на локальные данные</li>
</ul>
<h3 id="макросы">Макросы</h3>
<ul>
    <li>именовать макросы аналогично названию методов (при необходимости
        можно подменить)
    </li>
    <li>всегда заглавные</li>
    <li>предпочтение макросам
        <ul>
            <li>const для констант</li>
            <li>inline функция, будут компилироваться сразу в код</li>
            <li>enum, шаблоны, стандартные операции min/max &gt; Если вы используете
                макросы, это недостаток языка программирования, программы или
                программиста. &gt; Значит вам не хватает возможностей отладчиков,
                инструментов, профилирования. Бьерн Страуструп
            </li>
        </ul>
    </li>
</ul>
<h3 id="встраиваемые-методы">Встраиваемые методы</h3>
<ul>
    <li>ключевое слово inline</li>
    <li>повышает быстродействие, так как встраивается в код
        <ul>
            <li>НО:
                <ul>
                    <li>нарушение инкапсуляции</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="защитное-программирование">Защитное программирование</h3>
<ul>
    <li>Смысл - если методу передаются некорректные данные, то его работа не
        нарушится
    </li>
    <li>учитывать, что данные некорректные</li>
</ul>
<blockquote>
    <p>!! Не делать так: Мусор на входе - мусор на выходе Хорошая программа
        никогда не выдает мусор, независимо от того, что на входе Принцип: мусор
        на входе - ничего на выходе - обязательно проверка полученных данных от
        внешних интерфейсов - интервалы, разрешения, значения - определить как
        обрабатывать неправильные входные данные - assertion - утверждение, с
        помощью которого проверяется правильность выполнения - принимает
        логическое выражение, используется при: - проверка входных/выходных
        параметров - файловый поток открыт/закрыт, только для чтения - значения
        входных Не изменяются в методе - указатель не нулевой - контейнер пуст
        (заполнен), когда метод начинает/заканчивает выполнятся - утверждения
        используются только при разработке - и удаляются при компиляции
        промышленной версии - не помещать выполняемый код в утверждение -
        Предусловия - соглашения, которые код, вызывающий метод или класс,
        обещает выполнить до вызова метода или создания экземпляра - Постусловия
        - соглашения, которые метод или класс обещают выполнить при завершении -
        Утверждения - инструмент для документирования пред/пост-условий</p>
</blockquote>
<h3 id="способы-обработки-ошибок">Способы обработки ошибок</h3>
<ul>
    <li>Что вернуть при ошибке
        <ul>
            <li>нейтральное значение - типа пустая строка, пустой указатель,
                значение по умолчанию
            </li>
            <li>Но лучше, прекратить выполнение программы</li>
            <li>заменить корректным блоком данных
                <ul>
                    <li>получив некорректные данные из БД можно попытаться получить
                        новые
                    </li>
                </ul>
            </li>
            <li>вернуть тот же результат, что и в предыдущий раз</li>
            <li>можно вернуть ошибку разным способом - исключение, статус, вернуть
                обработчик ошибок:
                <ul>
                    <li>но лучше прекратить если это нужно в целях безопасности</li>
                    <li>ибо вернуть ошибку - можно предоставить данные наружу (этим могут
                        воспользоваться)
                    </li>
                    <li>инкапсулировать ошибку</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Устойчивость против корректности:
        <ul>
            <li>Корректность - нельзя возвращать неточный результат, т.е. лучше
                ничего, чем неточное
            </li>
            <li>Устойчивость - пытаться сделать что-то, что позволит программе
                продолжать работу даже если это приведет к неверным результатам
            </li>
            <li>Предпочитать Корректность!!</li>
        </ul>
    </li>
    <li>Реакция на неправильные значения везде одинаковая во всей
        программе
    </li>
    <li>Единый подход обработки ошибок</li>
</ul>
<h3 id="исключения">Исключения</h3>
<ul>
    <li>это специальное средство, позволяющее передать в вызов код возникшей
        ошибки или исключительной ситуации
        <ul>
            <li>типа я не знаю, что с этим делать разбирайтесь сами</li>
        </ul>
    </li>
    <li>генерация исключений оповещает об ошибках, которые нельзя
        игнорировать
    </li>
    <li>генерация исключений - только для действий в исключительных
        ситуациях
        <ul>
            <li>иначе говоря, не можешь обработать лучше сгенерить исключение</li>
        </ul>
    </li>
    <li>Нельзя в конструкторе/деструкторе генерить исключения</li>
    <li>Нельзя в мелочах, нельзя низкоуровневые исключения в высокоуровневых
        <ul>
            <li>учитывать инкапсуляцию в пробросе</li>
        </ul>
    </li>
    <li>достаточное описание исключений</li>
    <li>не допускать пустого блока catch(){}</li>
    <li>централизированный генератор сообщений об исключениях (логгер)</li>
    <li>Не допускать отладочных методов в промышленной версии</li>
</ul>
<h3 id="наступательное-программирование">Наступательное
    программирование</h3>
<ul>
    <li><p>чем жестче требования при разработке, тем проще
        эксплуатация</p></li>
    <li><p>если во время разработки вылетела ошибка, то это вариант, который
        не обработали</p></li>
    <li><p>удалять все отладочные средства</p></li>
    <li><p>использовать препроцессор для дебага (макросы)</p>
        <pre><code>    #define DEBUG
    #if define (DEBUG)
      ... code
    #endif</code></pre>
    </li>
    <li><p>использовать уровни отладки, используя значения</p>
        <ul>
            <li>if DEBUG == POINTER_ERROR &gt; LEVEL_A</li>
        </ul>
    </li>
    <li><p>можно использовать методы проверки, а во время эксплуатации их
        удалять, точнее очищать</p></li>
</ul>
<pre><code>void Func(Type* pointer){
  CheckPointer(pointer);
  ...code
};

void CheckPointer(void* pointer){
  // проверка на null, действующий и т.д.
}</code></pre>
<ul>
    <li>в эксплуатации метод CheckPointer заглушен, либо пуст, из основного
        кода не убирается!
    </li>
    <li>выбор
        <ul>
            <li>ПО падает при ошибке</li>
            <li>можно продолжить работать, поэтому надо выбирать между этими:
                <ul>
                    <li>оставить код, который проверяет существование ошибки
                        <ul>
                            <li>вычисления, расчеты</li>
                        </ul>
                    </li>
                    <li>удалить код, проверяющий незначительные ошибки
                        <ul>
                            <li>точнее просто записывает в лог</li>
                        </ul>
                    </li>
                    <li>удалить код, приводящий к прекращению работы:
                        <ul>
                            <li>остановка По только при разработке</li>
                            <li>нельзя, чтобы ошибка приводила к потере данных пользователя</li>
                        </ul>
                    </li>
                    <li>оставить код, который позволяет аккуратно завершить работу</li>
                    <li>регистрируйте ошибки для отдела техподдержки
                        <ul>
                            <li>по сути те ошибки которые завершают сделать их запись в журнал для
                                инженеров
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h2 id="псевдокод">Псевдокод</h2>
<ul>
    <li>ППП - Pseudocode Programming Process</li>
    <li>Этапы создания класса
        <ul>
            <li>создание общей структуры
                <ul>
                    <li>его функционал, уровень абстракции интерфейсов</li>
                </ul>
            </li>
            <li>конструирование методов
                <ul>
                    <li>потребность отдельных методов</li>
                </ul>
            </li>
            <li>оценка и тестирование класса
                <ul>
                    <li>после теста каждого отдельного метода, тестируется весь класс как
                        единое
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Этапы построения метода
        <ul>
            <li>многие методы асессоры иди интегральные простые</li>
            <li>остальные выполняются последовательно
                <ul>
                    <li>
                        <ol type="1">
                            <li>Проектирование метода -&gt; 2. Проверка структуры -&gt; 3.
                                Кодирование -&gt; 4. Пересмотр и тест -&gt; пункт 1
                            </li>
                        </ol>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="псевдонотация">ПсевдоНотация</h3>
<ul>
    <li>использовать формулировки в точности описывающие действия</li>
    <li>избегать синтаксических элементов языка программирования
        <ul>
            <li>мыслим на высоком уровне</li>
        </ul>
    </li>
    <li>использовать намерения, а не реализацию</li>
    <li>писать на таком уровне, чтобы код можно сгенерить автоматически
        <ul>
            <li>до тех пор, пока не покажется написать код будет проще
                <ul>
                    <li>пример,
                        <ul>
                            <li>Если ресурс доступен:
                                <ul>
                                    <li>выделить структуру для окна</li>
                                </ul>
                            </li>
                            <li>Конец если:
                                <ul>
                                    <li>если не доступен, вернуть false</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>псевдокод - по сути код, который преобразуется в исходный</li>
    <li>проще искать ошибку в псевдокоде</li>
    <li>по сути псевдокод есть комментарии</li>
</ul>
<h3 id="конструирование-методов-с-ппп">Конструирование методов с
    ППП</h3>
<h4 id="проектирование-метода">Проектирование метода</h4>
<ul>
    <li>определите задачу, решаем методом</li>
    <li>настолько детально, чтобы можно перейти к созданию метода
        <ul>
            <li>инфо, скрываемую</li>
            <li>вх/вых параметры</li>
            <li>постусловия, предусловия</li>
            <li>обработка ошибок</li>
        </ul>
    </li>
    <li>название метода должно быть Недвусмысленным</li>
    <li>подумать о тестировании метода</li>
    <li>исследовать функциональность стандартной библиотеки</li>
    <li>можно ли код переиспользовать, либо использовать стандартную
        библиотеку
    </li>
    <li>заголовок комментарий метода (можно несколько строк), а потом
        псевдокод
    </li>
    <li>прочитать еще раз псевдокод иди зачитать кому-то
        <ul>
            <li>можно сделать несколько идей псевдокода и выбрать лучший</li>
            <li>проходить по псевдокоду раз за разом, пока не будет казаться
                настолько простым, что его можно использовать вместо кода
            </li>
        </ul>
    </li>
</ul>
<h4 id="кодирование-метода">Кодирование метода</h4>
<ul>
    <li>объявление метода - первый и последний операторы (про {}) -
        псевдокод закомментировать - добавить код после каждого элемента
        <ul>
            <li>проверить код - исправить неточности</li>
        </ul>
    </li>
</ul>
<h4 id="проверка-кода">Проверка кода</h4>
<ul>
    <li>скомпилировать с усиленными требованиями, с санитайзерами</li>
    <li>стараться более тщательно проверить до компиляции</li>
    <li>пройтись отладчиком по всем строкам</li>
    <li>протестировать</li>
</ul>
<h4 id="наведение-глянца">Наведение глянца</h4>
<ul>
    <li>проверить интерфейс метода
        <ul>
            <li>убедиться, что используются все вх/вых параметры</li>
            <li>проверить наименование переменных, форматирование</li>
            <li>удалить лишние комментарии</li>
        </ul>
    </li>
</ul>
<h3 id="альтернативы-ппп">Альтернативы ППП</h3>
<ul>
    <li>ТДД - Test-Driven-Development
        <ul>
            <li>тестирование до кода</li>
        </ul>
    </li>
    <li>рефакторинг</li>
    <li>проектирование по контракту</li>
</ul>
<h2 id="переменные">Переменные</h2>
<ul>
    <li>обязательно инициализировать каждую переменную</li>
    <li>всегда указывать тип</li>
    <li>максимально объявлять как const/final</li>
    <li>внимательно следить за счетчиками/аккумуляторами, особенно с
        обнулением
    </li>
    <li>проверка повторной инициализации</li>
    <li>использовать проверку доступа и памяти для обнаружения неверно
        инициализированных указателей
    </li>
    <li>интервал между обращение к переменной делать как можно меньше</li>
</ul>
<pre><code>a = 0
b = 0
c = 0
b = 1 // интервал 2</code></pre>
<ul>
    <li>чем меньше(короче) интервал, тем меньше жизнь переменной
        <ul>
            <li>это снижает окно уязвимости</li>
        </ul>
    </li>
    <li>переменные для цикла инициализировать непосредственно перед
        циклом
    </li>
    <li>не присваивать значения переменным вплоть до его использования</li>
    <li>группировать по смыслу, не объявлять все в одной группе</li>
    <li>разбивать группы связанных команд на отдельные методы
        <ul>
            <li>тем самым уменьшается область видимости переменной</li>
        </ul>
    </li>
    <li>ограничивать область видимости одним методом, циклом</li>
</ul>
<h3 id="персистентность">Персистентность</h3>
<ul>
    <li>это характеристика длительности существования данных
        <ul>
            <li>определение жизни переменной в блоке, оператором delete, сборщиком
                мусора
            </li>
        </ul>
    </li>
    <li>дял избежания проблем
        <ul>
            <li>при завершении работы с переменной, присваивайте nullptr</li>
            <li>всегда считайте, что данные не являются персистентными</li>
            <li>обновлять и инициализировать все данные перед использованием</li>
        </ul>
    </li>
</ul>
<h3 id="время-связывания">Время связывания</h3>
<ul>
    <li>это момент, когда переменные и ее значение связываются вместе
        <ul>
            <li>определить этот момент при написании кода, компиляции, загрузке</li>
        </ul>
    </li>
    <li>чем позже связывание тем гибче код</li>
    <li>чем раньше тем ниже гибкость и ниже сложность</li>
    <li>константы лучше при компиляции</li>
</ul>
<h3 id="связь-между-типами-данных-и-управляющими-структурами">Связь
    между типами данных и управляющими структурами</h3>
<ul>
    <li>последовательные данные
        <ul>
            <li>считывание в определённом порядке
                <ul>
                    <li>имя - фамилия - возраст</li>
                </ul>
            </li>
            <li>селективные - if else</li>
            <li>итеративные - все вместе + рекурсия &gt; Одна переменная одна
                цель
            </li>
        </ul>
    </li>
    <li>имя переменной должно точно описывать сущность
        <ul>
            <li>описывает аспект вычислений, а не проблемы (в отличии от названия
                метода)
            </li>
            <li>идеально 10-16 символов</li>
            <li>8-20 допустимо</li>
            <li>без артиклей, предлогов</li>
        </ul>
    </li>
    <li>для глобальных имен использовать namespace - UserInterface/System
        <ul>
            <li>java - использовать пакеты</li>
            <li>спецификаторы вычислительных значений ставим в конце
                <ul>
                    <li>total, sum, average, max, record, string pointer
                        <ul>
                            <li>customerIndex, customerCount</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>используем антонимы
        <ul>
            <li>locked/unlocked</li>
            <li>next/previous</li>
            <li>first/last</li>
        </ul>
    </li>
    <li>индексы циклов - i, j, k
        <ul>
            <li><p>переменная для цикла вне цикла - используй имя</p>
                <pre><code>  recordCount = 0;
  while(moreScores(){
    score[recordCount] = ...
    recordCount++;
  }</code></pre>
            </li>
        </ul>
    </li>
    <li>при вложенном цикле стараться использовать имя для переменной вместо
        i, j
    </li>
    <li>статусы пример:</li>
</ul>
<pre><code>dataReady = true
characterType = control_charqacter
const int LETTER = 0x01</code></pre>
<ul>
    <li>временные - точно будь уверен, что она временная и будет не
        использоваться в основном блоке
        <ul>
            <li>при swap, удалении</li>
        </ul>
    </li>
    <li>булевые
        <ul>
            <li>clone, found, success</li>
            <li>лучше отказаться от is&lt;имя булевой переменной&gt;</li>
            <li>также плохо not, лучше notFound
                <ul>
                    <li>использовать утвердительные имена</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>константы
        <ul>
            <li>ЗАГЛАВНЫЕ_ЧЕРЕЩ_НИЖНЕЕ_ПОДЧЕРКИВАНИЕ</li>
            <li>при этом абстрактные сущности
                <ul>
                    <li>CYCCES_NEEDED лучше чем FIVE</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3 id="конвекции-именования">Конвекции именования</h3>
<ul>
    <li>определить названия методов и переменных
        <ul>
            <li>провести отличие</li>
        </ul>
    </li>
    <li>отделить объекты от классов</li>
    <li>обязательно идентифицировать Глобальные переменные
        <ul>
            <li>хотя-бы g_RunningTotal</li>
        </ul>
    </li>
    <li>идентифицировать типы
        <ul>
            <li>COLOR либо t_Color</li>
        </ul>
    </li>
    <li>перечисления
        <ul>
            <li>Color</li>
        </ul>
    </li>
    <li>идентифицировать константы
        <ul>
            <li>RECS_MAX</li>
        </ul>
    </li>
    <li>если пишешь на двух языках конвенцию делать общей</li>
    <li>имя переменной должно включать информацию 3х видов
        <ul>
            <li>суть</li>
            <li>тип данных (константа, класс, тип)</li>
            <li>область видимости</li>
        </ul>
    </li>
</ul>
<h3 id="область-видимости">Область видимости</h3>
<ul>
    <li>венгерская нотация - состоит из 2-х частей
        <ul>
            <li>аббревиатура типа (user_defined type, ИДТ)
                <ul>
                    <li>ch - не символ, а тип данных для символа</li>
                </ul>
            </li>
            <li>семантические префиксы
                <ul>
                    <li>first/last - первый последний - firstActiveElement</li>
                    <li>lim, max, min -</li>
                </ul>
            </li>
            <li>стараться не использовать BLN</li>
        </ul>
    </li>
</ul>
<h3 id="сокращение-имен">Сокращение имен</h3>
<ul>
    <li>особо не увлекаться</li>
    <li>примеры
        <ul>
            <li>удалять артикли и союзы end, Or, the</li>
            <li>удалять префиксы суффиксы ing, ed</li>
        </ul>
    </li>
    <li>если все таки используешь сокращения - заноси в документацию</li>
    <li>избегать названия переменных, отличающихся на одну букву
        <ul>
            <li>тяжело будет отличать</li>
            <li>также похожие символы тоже плохо i - l, I-l</li>
        </ul>
    </li>
    <li>избегать чисел в переменных</li>
</ul>
<h3 id="основные-типы-данных">Основные типы данных</h3>
<ul>
    <li>избегать непонятных чисел в коде, для этого есть переменные</li>
    <li>избегать сравнений разных типов</li>
</ul>
<h3 id="целые-числа">Целые числа</h3>
<ul>
    <li>проверять перед делением
        <ul>
            <li>7/10 - будет 0</li>
            <li>10&amp;(7/10) - будет 0</li>
        </ul>
    </li>
    <li>переполнение, особенно при умножении и Промежуточных
        результатах
    </li>
</ul>
<h3 id="числа-с-плавающей-точкой">Числа с плавающей точкой</h3>
<ul>
    <li>всегда учитывать, что дробные числа не могут быть точно представлены
        <ul>
            <li>1/3 - будет например точность 7 знаков - 0,3333333</li>
        </ul>
    </li>
    <li>избегать сложных и слишком больших вычислений
        <ul>
            <li>а также разных по размеру</li>
        </ul>
    </li>
    <li>избегать проверку на равенство
        <ul>
            <li>они не всегда равны</li>
            <li>использовать интервал сравнения</li>
        </ul>
    </li>
</ul>
<h3 id="символы-и-строки">Символы и строки</h3>
<ul>
    <li>не использовать магические литеральные символы типа “А”</li>
    <li>следить за выходом за границу строки при обращении</li>
    <li>узнать как ваш язык поддерживает Unicode
        <ul>
            <li>а то получиться, что нельзя будет использовать</li>
        </ul>
    </li>
    <li>интернационализация (локализация) предусматривается в самом
        начале
    </li>
</ul>
<h3 id="логические-переменные">Логические переменные</h3>
<ul>
    <li>выражения дял сравнений присваивать переменной
        <ul>
            <li>finished = … || … &amp;&amp; …</li>
        </ul>
    </li>
    <li>особенно если используете несколько условий, лучше вынести каждое
        условие в отдельную переменную
    </li>
</ul>
<h3 id="перечисляемые-типы">Перечисляемые типы</h3>
<ul>
    <li>использовать особенно, где используется true/false как передача
        параметра
    </li>
    <li>особенно при возврате логического true/false ибо потом можно быть
        два варианта false
    </li>
    <li>использовать для Switch/case</li>
</ul>
<h3 id="именнованные-константы">Именнованные константы</h3>
<ul>
    <li>выделять Заглавными поля класса</li>
    <li>вместо магических цифр делаем константу</li>
</ul>
<h3 id="массивы">Массивы</h3>
<ul>
    <li>предпочитать контейнеры, списки, очереди массиву
        <ul>
            <li>типа много ошибок выхода за границы</li>
        </ul>
    </li>
</ul>
<h3 id="собственные-типы">Собственные типы</h3>
<ul>
    <li>можно определить даже простые для удобства дальнейшего
        использования
    </li>
</ul>
<pre><code>typedef float Coordinate;
Route {
  Coordinate latitude;
  Coordinate longitude;
}</code></pre>
<ul>
    <li>можно потом поменять быстро и легко</li>
    <li>избегать имен типов, которые ссылаются на данные, лежащие в основе
        <ul>
            <li>абстрактные (изолирующие) названия</li>
        </ul>
    </li>
    <li>использовать собственные типы везде где можно</li>
    <li>лучше сделать класс вместо typedef</li>
</ul>
<h3 id="нестандартные-типы-данных">Нестандартные типы данных</h3>
<ul>
    <li>тип данных, построенный на основе других</li>
    <li>группировка в одну сущность нескольких типов</li>
</ul>
<pre><code>Emploee {
  name: String
  address: String
}</code></pre>
<ul>
    <li>в методе в качестве параметра аккуратно использовать структуры, ибо
        не всегда нужны все параметры
        <ul>
            <li>передаем только те что используются</li>
        </ul>
    </li>
</ul>
<h3 id="указатели">Указатели</h3>
<ul>
    <li>очень аккуратно используем, очень часто ошибки, что указывает не
        туда
    </li>
    <li>самые сложные ошибки</li>
    <li>изолировать операции с указателями в отдельный класс, метод</li>
    <li>объявлять и определять указатели Одновременно</li>
    <li>удалять указатели в той же области, где они были созданы</li>
    <li>проверять указатели перед использованием</li>
    <li>использовать закрепленные признаки дял проверки повреждения памяти
        <ul>
            <li>можно добавить поле (как флаг) и проверять по нему корректность
                данных, и помечать его если данные уничтожены,
                <ul>
                    <li>то есть проверять по нему</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Никогда не используй одну переменную для разных указателей</li>
    <li>упрощать сложные выражения указателей
        <ul>
            <li>ptr = rates -&gt; discounts -&gt; factors -&gt; net
                <ul>
                    <li>далее использовать уже ptr, а не цепочку</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>удалять указатели в связных списках в правильном порядке
        <ul>
            <li>перед удалением в списке сначала убедиться, что есть указатель на
                следующий элемент
            </li>
        </ul>
    </li>
    <li>устанавливать nullptr на указатели при удалении или освобождении
        <ul>
            <li>чтобы не было высячего указателя
                <ul>
                    <li>delete pointer</li>
                    <li>pointer = nullptr</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>указатель &amp; ссылка
        <ul>
            <li>указатель object-&gt;field, может быть nullptr</li>
            <li>ссылка object.field
                <ul>
                    <li>всегда ссылается на объект</li>
                    <li>после инициализации нельзя изменить куда она ссылается</li>
                </ul>
            </li>
            <li>для передачи по значению использую указатель</li>
        </ul>
        <pre><code>  void DomeFuncion( const LargeObject&amp; nomodifyObj, LargeObject* modifyObj)
  - изменяемый по указателю modifyObj-&gt;field
  - а неизменяемый nomodifyObj.field</code></pre>
        -Хороший тон const везде где можно
    </li>
    <li>использовать автоматический указатель auto ptr
        <ul>
            <li>при выходе из области видимости память автоматически
                освободится
            </li>
        </ul>
    </li>
</ul>
<h3 id="глобальные-переменные">Глобальные переменные</h3>
<ul>
    <li>стараться использовать только локальные, либо полученные из
        метода
    </li>
</ul>
<h3 id="методы-доступа">Методы доступа</h3>
<ul>
    <li>скрываем данные в классе как static
        <ul>
            <li>дает гарантию единственного экземпляра</li>
        </ul>
    </li>
    <li>либо через метод к внутренней переменной, но называется типа
        globalVat -&gt; Get() - Status()
    </li>
    <li>требуйте, чтобы весь код обращался через методы доступа</li>
    <li>можно сделать соглашение начинать глобальные переменные с g_, и
        только через методы доступа
    </li>
    <li>не складывать все глобальные в одно место</li>
    <li>управление глобальными переменными с помощью блокировок
        <ul>
            <li>использовать флаг - checkIn/out</li>
            <li>при использовании переменной другие не могут получить (возможно даже
                исключение)
            </li>
        </ul>
    </li>
    <li>не нужно уточнение, используем абстракцию
        <ul>
            <li>node - node.next - Плохо</li>
            <li>event - eventQueue.queueFront - Плохо</li>
            <li>event = HighestPriorityEvent() - Хорошо</li>
            <li>account = NextAccount.account, Add/RemoveEvent - Хорошо</li>
        </ul>
    </li>
    <li>если считали через метод доступа, то и записывать также</li>
    <li>не путать глобальные переменные и именованные константы, вот
        константы можно и нужно использовать, а вот переменные избегать
    </li>
</ul>
<h2 id="операторы">Операторы</h2>
<h3 id="организация-наследовательного-кода">Организация
    наследовательного кода</h3>
<ul>
    <li>организуйте код так, чтобы зависимости были очевидны
        <ul>
            <li>т.е. если последовательное выполнение это очевидно ``` // очевидно
                data = ReadData() results = CalculateFrontData(data)
                PrintResults(results)
            </li>
        </ul>
    </li>
</ul>
<p>// Плохо и неочевидно // все скрыто внутри и не понятно что и как
    ComputeData() CalculateData() Print()</p>
<pre><code>- писать код без порядковых зависимостей
  - делать код зависимостей очевидным
    - если не очевидно, добавьте комментарий и документацию
- если все таки производится использовать полезные зависимости, то внутри них можно использовать флаги выполнения зависимостей
  - например, A(), B(), C()
    - в B() - проверяем isA = true
    - в C() - проверяем isB = true
- при произвольном порядке, тею все равно кто за кем</code></pre>
<p>// плохо A a; B b; C c;</p>
<p>a.start() b.start() c.start()</p>
<p>a.logic() b.logic() c.logic()</p>
<ul>
    <li><p>при таком трудно отследить выполнение одной группы</p></li>
    <li><p>лучше A a; a.start(); a.logic(); …</p></li>
</ul>
<pre><code>- размещайте взаимосвязанные выражения вместе
  - чтобы убедиться, что они взаимосвязаны
    - распечатайте, и обведите группы в рамки
    - если рамки не пересекаются, то ОК

### Условные операторы
- писать код так, чтобы нормальный путь был очевиден
- размещать Нормальный вариант после if, а не в else
  - в else - некорректный вариант
    - даже при большом количестве if/else</code></pre>
<p>Logic();</p>
<p>if(status == ..){ NextLogic();</p>
<p>if(statusNext == ..) { LastLogic(); } else { error ‘NextLogic’; } }
    else { error ‘Logic’; }</p>
<pre><code>- здесь все очевидно. где нормальная логика, где чья обработка ошибки
- если используете только if без else
  - подумай можно ли (а точнее Нужно) ли использовать else, чтобы указать, что вариант else учтен
  - если else нет, лучше указать в комментарии почему
- при большом количестве аргументов в if выносить в выражения отдельных логических функций
- при многократном if - else
  - в первые (вначале) проверки выносить часто встречающиеся
    - типа сначала поиск по диапазону а-А, потом по 1-9 если просто строки
  - убедиться, что учтены все варианты
    - т.е. в последнем else сообщить, что, например, ошибка неизвестна (т.к. все типы обработаны ранее)
- если язык поддерживает switch, то используем его вместо многократного if-else
  - выбор наиболее эффективного порядка вариантов switch
  - если малое количество case, то все равно switch
  - если много, то по алфавиту или численно
    - либо первый правильный, редкий, частый
  - обработка внутри case
    - обработка простая
    - не нужно в default - использовать как правильный!!, лучше его для выявления ошибок

## Циклы
- виды
  - выполняется определенное количество раз
  - постоянный до условия
  - бесконечный
  - по Итераторам
- while
  - если знаем заранее сколько будет операций
  - цикл с проверкой в начале while
  - цикл с проверкой в конце do while
  - все условия выхода размещать в одном месте
- for
  - если нужен цикл по определенному количеству раз
  - инкремент/декремент, обход элементов контейнера

### Управление циклом
- вход в цикл только в одном месте
- инициализированный код непосредственно перед циклом
- для бесконечного цикла while(true), либо for(;;)
- один цикл один метод
- завершение while очевидное и в начале
- при for(i; i&lt;..; ++i) - i Нигде не менять, он сам меняется
- лучше break вместо логических флагов
  - но много break нельзя!!
- continue использовать в начале цикла
  - если continue возникает в середине или в конце лучше вместо него if
- в Java можно использовать break с меткой, выход до определенного участка
- вообще break/continue использовать аккуратно:
  - использовать break если других альтернатив нету
- если перебор многомерный, лучше вместо индексов использовать смысловые переменные
  - вообще стараться всегда использовать Смысловые переменные в циклах
  - плохо, sim = sim + transaction.i.j
  - хорошо sum = sum + transaction.month.day
- ограничить видимость переменных индексов самим циклом
- Длина цикла
  - делать коротким
    - максимум количество на экране (~50)
    - хорошо 5-20 строк
  - максимум 3 вложенности
  - внутрення часть длинных циклов в отдельные методы

## Нестандартные управляющие структуры
- вместо else - return</code></pre>
<p>// плохо if(logic) { return some; } else if(..){ .. }</p>
<p>// хорошо if(one) return if(two) return</p>
<pre><code>
- избегать большой вложенности, лучше сразу return

### Рекурсия
- убедиться, что рекурсия остановиться
  - можно использовать счетчик безопасности для выхода из рекурсии (лимит переходов например)
- следить за размером стека
- плохо для Фибонначи и Факториала

### Табличные методы
- это схема, позволяющая искать инфо в таблице,
  - а не использовать дял этого логические выражения
- например, выборка логики при какой-то букве
  - можно в if-else и много условий
  - либо использовать таблицу (заранее заполненную)
    - для поиска записи в таблице
      - прямой доступ
      - индексированный доступ
      - ступенчатый
    - определить, что храниться

### Таблицы с прямым доступом
- позволяет обращаться к требуемому элементу напрямую
  - например, определение количества дней в месяце</code></pre>
<pre><code>int days
  if(month == 1) days = 31
  if(month == 2) days = 28</code></pre>
<pre><code>- это Ужасно!!
- лучше использовать словарь (множество) даже массив</code></pre>
<pre><code>MothDays = [21,28,30,..]
- обращаться через индекс месяца</code></pre>
<pre><code>- таблицу можно использовать, когда несколько разных условий одновременно
- например,</code></pre>
<pre><code>if(gender == Gender.Female) {
  if(maritalStatus == MaritakStatus.Single) {
    if(age &lt; 18) {
      ...
    }
  }
} </code></pre>
<pre><code>- лучше несколько таблиц:</code></pre>
<pre><code>Enum GenderStatus {
  First = 0,
  Male = 0,
  Female = 1,
  Lasr = 1
}

Enum MaritalStatus {
  First = 0,
  Single = 0,
  ...
}

const MAX_AGE = 125;

GenderStatus gender(Gender.First);
MaritalStatus maritalStatus(MaritalStatus.Last);
int age = 18;</code></pre>
<p>rate = rateTable(gender, maritalStatus, age)
    <code>- вместо if-else используем варианты из Enum с одним полем</code>
    class AbstractField { virtual ReadAndPrint(….) }</p>
<p>class FactoryPointFiled: public AbstractField { virtual
    ReadAndPrint(….) } …</p>
<p>// создаем таблицу для хранения всех видов field</p>
<p>AbstractField* filed;</p>
<p>field[Field.FloatingPoint] = new FloatingPointField()
    field[Field.TimeOrDay] = new TimeOrDayField() ``` - соответственно
    получаем по ключу Enum Field нужный (но при этом) скрытый класс и
    используем его в методу абстрактного класса - паттерн сокрытые и
    разделение выполнения от реализации</p>
<h4 id="подгонка-значению-ключа">Подгонка значению ключа</h4>
<ul>
    <li>дублирование информации в предыдущем пример,
        <ul>
            <li>поле age некорректно было бы выносить в таблицу для каждого года
                отдельное значение,
                <ul>
                    <li>когда у нас до 18, 18, 19-60 и старше</li>
                </ul>
            </li>
            <li>преобразовать ключБ чтобы использовать напрямую</li>
        </ul>
    </li>
    <li>использовать к переменной Age функцию, которая преобразовывает к
        диапазонам
        <ul>
            <li>max(min(66, Age), 17)</li>
            <li>здесь будет тяжело если будет много диапазонов</li>
        </ul>
    </li>
    <li>изоляция преобразования ключа
        <ul>
            <li>получение ключа у метода (или Hash) - KeyFromAge()</li>
        </ul>
    </li>
</ul>
<h3 id="таблицы-с-индексированным-доступом">Таблицы с индексированным
    доступом</h3>
<ul>
    <li>использование промежуточного индекса, когда недостаточно
        преобразования как с Age
        <ul>
            <li>например,
                <ul>
                    <li>у меня 100 наименований, а элементы имеют индексы 4х значные 0 -
                        9999, и тогда массив в основном будет пустой
                        <ul>
                            <li>так как используется всего 100</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>тогда можно сжать используя индексы преобразования из 4х значных - в
        до 100
    </li>
    <li>такой подход дает возможность уйти от любых наименований типа 4х
        значных (имена, фамилии, специальности)
    </li>
    <li>и просто индексами через адаптеры</li>
    <li>это даст удобнее манипулировать элементами индекса, общее
        сопровождение независимо от внешних факторов - абстрагироваться
    </li>
</ul>
<button class="button_up" id="scrollTopBtn" title="Наверх">↑</button>
<script>
    const btn = document.querySelector('.button_up')

    btn.addEventListener("click", () => {
        window.scrollTo({top: 0, behavior: 'smooth'});
    });
</script>
</body>
</html>
