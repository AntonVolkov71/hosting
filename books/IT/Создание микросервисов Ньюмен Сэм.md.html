<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Создание микросервисов Ньюмен Сэм.md</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Создание микросервисов Ньюмен Сэм.md</h1>
</header>
<h1 id="создание-микросервисов-ньюмен-сэм">Создание микросервисов Ньюмен
Сэм</h1>
<h1 id="прочитана">Прочитана</h1>
<h2 id="глава-8-тестирование">Глава 8 Тестирование</h2>
<p><strong>Init (module)</strong> - маленький участок тестирования
(метод, класс)</p>
<p><strong>Service</strong> - что-то маленькое целое. - СДС -
consumer-driven-contracts - тест по контрактам - эксплуатационные -
микросервис, регистрация и т.д.</p>
<p><strong>Сквозное</strong> (UI) - вся система</p>
<blockquote>
<p>Больше UI - дальше выпуск, тяжелее найти ошибку Unit - больше,
быстрее debug, но не известно работает ли вся система</p>
</blockquote>
<p><strong>Лучшая середина:</strong> - Unit - 40-80% - Service - 20-30%
- UI - 1-5%</p>
<h3 id="веерное-тестирование">Веерное тестирование:</h3>
<pre><code>Service_1 -&gt; Unit-&gt;Service-&gt; 
                             -&gt;       UI
Service_2 -&gt; Unit-&gt;Service-&gt; </code></pre>
<h3 id="сервисы-тестирования">Сервисы тестирования:</h3>
<ul>
<li>локально установить
<ul>
<li>mountebank</li>
<li>pact</li>
</ul></li>
<li>JVM
<ul>
<li>Spring Cloud Contract</li>
</ul></li>
</ul>
<p><strong>Дымовое тестирование</strong> - в рамках развертывания и
проверки запуска</p>
<p>Канареечное - выборочное на части пользователей</p>
<p><strong>CRF</strong> - cross-functional-requirements (кросс
функциональное - не функции) - задержка передачи по сети -
производительность - скорость - имитация сбоев (сетевых)</p>
<p>CRF - достаточно 1 раз в неделю</p>
<hr />
<h2 id="глава-9-мониторинг">Глава 9 Мониторинг</h2>
<ul>
<li><p><strong>Наблюдаемость</strong> - степень, в которой можно понять
внутренне состояние, основываясь на внешних данных</p></li>
<li><p>Система сама выдает выходные данные - log, metrics</p></li>
</ul>
<h3 id="агрегация-логов">Агрегация логов</h3>
<pre><code>экзепляр    локально   | период отсылка   
экзепляр    ---&gt; логи  |  ------------&gt;   логи
экзепляр               |

- возможность в агрегированных логам фильтровать по составу сообщения</code></pre>
<h4 id="состав-логов">Состав логов</h4>
<ul>
<li>id вызова (путь процедуры, даже если несколько микросервисов)</li>
<li>дата, время</li>
<li>имя микросервиса</li>
<li>уровень лога</li>
</ul>
<h5 id="пример-записи-лога">Пример записи лога</h5>
<pre><code>- 15-02-2024 16:00:01 Order INFO [abc-123] Customer Message
- [abc-123] - id вызова</code></pre>
<h3 id="сервисы-мониторинга">Сервисы мониторинга:</h3>
<ul>
<li>Humio</li>
<li>Datadog</li>
</ul>
<h3 id="с-чего-начать-мониторинг">С чего начать мониторинг:</h3>
<ul>
<li>инфо о хостах, где запущены микросервисы</li>
<li>скорость отклика микросервиса</li>
</ul>
<p><strong>Синтетические транзакции</strong> - искусственные операции
(вместо пользователя) - собирают всю информацию - используются как
тест</p>
<h3 id="sli---service-level-indicator">SLI - service level
indicator</h3>
<ul>
<li>индикатор сервиса услуг</li>
<li>показатель, что делает ПО
<ul>
<li>время отклика</li>
<li>регистрация клиента</li>
<li>размещение заказа</li>
</ul></li>
</ul>
<hr />
<h2 id="глава-10-безопасность">Глава 10 Безопасность</h2>
<p><strong>Принцип наименьших привилегий</strong> - минимальный доступ
на конкретный период, с минимальной функциональностью</p>
<h3 id="средства-контроля">Средства контроля:</h3>
<ul>
<li><strong>Превентивный</strong> - предотвращение (безопасное хранение
ключей, шифрование)</li>
<li><strong>Детективный</strong> - оповещение об атаке</li>
<li><strong>Реагирующий</strong> - реакция во время/после атаки</li>
</ul>
<h3 id="разбивка-на-зоны">Разбивка на зоны</h3>
<pre><code>общедоступная &lt;-- &lt;----
                |     |
частная --------|     |
частная &lt;--------     |
                |     |
секретная-------|-----|</code></pre>
<ul>
<li>От секретной к частной и общедоступной, НО НЕ НАОБОРОТ</li>
</ul>
<h3 id="принципы">Принципы</h3>
<ul>
<li>упрощенные данные, обрезанные (например, последние цифры IP)</li>
<li>имя, пол, например без возраста, только чтение</li>
<li>хранить данные в зашифрованном виде</li>
<li>делать бекап данных тоже в зашифрованном виде</li>
</ul>
<blockquote>
<p>Если вы не храните данные, никто не сможет их украсть и не сможет
запросить. Лучше научиться восстановить систему, чем пытаться избегать
падения.</p>
</blockquote>
<hr />
<h2 id="глава-10-отказоустойчивость">Глава 10 Отказоустойчивость</h2>
<p><strong><em>Изоляция</em></strong> - микросервис на отдельном хосте -
у каждого микросервиса своя БД (Отдельная инфраструктура баз данных)</p>
<ul>
<li><strong>Избыточность</strong> - несколько экземпляров запущенного
микросервиса</li>
<li><strong>Идемпотемпотентость</strong> - постоянные ответы,
запросы</li>
<li><strong>Распределение рисков</strong> - не класть все яйца в одну
корзину</li>
</ul>
<h3
id="теорема-cap---consistency-availability-and-position-tolerance">Теорема
CAP - consistency, availability and position tolerance</h3>
<ul>
<li><strong>Согласованность</strong> - получим один и тот же ответ, если
перейдем к нескольким узлам</li>
<li><strong>Доступность</strong> - каждый запрос получает ответ</li>
<li><strong>Устойчивость</strong> к разделению - способность системы к
тому, что связь между частями иногда невозможна</li>
</ul>
<blockquote>
<p>!!! Выбираем 2 из 3 -&gt; CP-AP</p>
</blockquote>
<h3 id="хаос-инжиниринг">Хаос инжиниринг</h3>
<ul>
<li>типа учения пожарного поезда, только на рабочей системе</li>
<li>дисциплина, об экспериментировании с системой с целью укрепления
уверенности способности системы выдерживать турбулентные условия в
эксплуатации</li>
<li>типа, давай вырубим одну систему и посмотрим, что будет</li>
</ul>
<blockquote>
<p>Системы это не только ПО, а люди, инфрастуктура, процессы</p>
</blockquote>
<h3 id="dirt---disaster-recovery-testing">Dirt - disaster recovery
testing</h3>
<ul>
<li>тестирование аварийного восстановления</li>
</ul>
<h3 id="сервисы-для-тестирования-отказоустойчивости">Сервисы для
тестирования отказоустойчивости</h3>
<ul>
<li>ChaosMonkey - в определенное время отключает случайные машины</li>
<li>Latency Monkey - имитирует медленное сетевое соединение</li>
<li>Chaos toolkit</li>
<li>Gremlin, Reliably</li>
</ul>
<hr />
<h2 id="глава-13-масштабирование">Глава 13 Масштабирование</h2>
<ul>
<li><p><strong>Вертикальное</strong> - более мощная машина</p></li>
<li><p><strong>Горизонтальная (дублирование)</strong> - наличие
нескольких устройств, способных выполнять одну и ту же работу</p></li>
<li><p><strong>Разделение данных</strong> - разделение работы на основе
какого либо атрибута данных (группы пользователей, А-Н и Н-Я)</p></li>
<li><p><strong>Функциональная декомпозиция</strong> - разделение работы
в зависимости от типа (у монолита выделить часть)</p></li>
</ul>
<h3 id="шаблон-cqrs---command-query-responsibility-segregation">Шаблон
CQRS - command query responsibility segregation</h3>
<ul>
<li>модели чтения и записи разделены (разные модули)</li>
</ul>
<h3 id="кеш">Кеш</h3>
<ul>
<li>хранить на стороне клиента данные</li>
<li><strong>Кеш-провал</strong> - когда нет данных в кеше (а они есть),
после чего запрос за данными и аннулирование кеша</li>
<li><strong>Кеш-промах</strong> - в кеше данные есть, но при работе с
этими данными ошибка -&gt; аннулирование кеша</li>
</ul>
<h3 id="хранение-кеша">Хранение кеша</h3>
<ul>
<li><strong>плохое</strong> - Кеш можно хранить в каждом сервисе,
который его использует, но тогда будет проблема согласованности
данных</li>
<li><strong>лучше</strong> (но не самое) - на основе Redis, memcached
<ul>
<li>каждый сервис хранит у себя “Кеш сервиса”, и несет за него
ответственность</li>
<li>клиенты все равно делают запрос в этот сервис, но при этом сервис
“облегчен”</li>
</ul></li>
</ul>
<h3 id="аннулирование-кеша">Аннулирование кеша</h3>
<ul>
<li>время жизни TTL - time to live
<ul>
<li>используется при http запросах (заголовок cache-control)
<ul>
<li>условные GET-запросы</li>
<li>ETAG - позволяет определить имеется ли ресурс, если у клиента
последняя версия ответ “304 not modified”</li>
</ul></li>
</ul></li>
<li>на основе уведомлений - через брокер, уведомлять клиента об
устаревании
<ul>
<li>проблема при этом - ни клиент ни сервис не знают об уведомлении
(брокер может сбоить)</li>
<li>решается периодическим запросом “пульс” живой-неживой</li>
</ul></li>
<li><strong>Сквозное кеширование</strong> - обновление кеша сразу при
изменении данных в сервисе</li>
<li><strong>Кеш с последующей записью</strong> - сначала заполняется
кеш, типа буфера данных, потом запись в БД</li>
</ul>
<h3 id="золотое-правило-кеширования">Золотое правило кеширования</h3>
<ul>
<li>кеширование как оптимизация!!</li>
</ul>
<blockquote>
<p>Идеальное количество мест для кеширования равно НУЛЮ. Преждевременная
оптимизация может вызвать проблемы</p>
</blockquote>
<h3 id="автоматическое-масштабирование">Автоматическое
масштабирование</h3>
<ul>
<li>вычисляем пики (период времени), автоматически увеличиваем
количество экземпляров в эти периоды (AWS - может такое)</li>
</ul>
<blockquote>
<p>НАЧИНАЕМ ВСЕ С НАЧАЛА - изменение архитектуры с появившейся нагрузкой
Необходимость изменения системы - это признак успеха Не нужно сразу
строить супер архитектуру!!!</p>
</blockquote>
<hr />
<h2 id="глава-14-ui---пользовательский-интерфейс">Глава 14 UI -
Пользовательский интерфейс</h2>
<ul>
<li><strong>GUI</strong> - graphical user interface</li>
</ul>
<h3 id="принцип-разделения-команд">Принцип разделения команд</h3>
<ul>
<li><strong>Плохое</strong>
<ul>
<li>Фронт команда - занимается фронтом всего сервиса</li>
<li>Бек команда - занимается беком всего сервиса</li>
<li>АБД - занимается всеми БД</li>
</ul></li>
<li><strong>Лучшее</strong>
<ul>
<li>Фронт, бек, АБД это одна команда - занимаются одним сервисов НО
ПОЛНОСТЬЮ (фулстек команда, не путать с фулстек разработчиком)</li>
<li>при таком, одна команда отвечает за свою область</li>
</ul></li>
</ul>
<h3 id="микрофронтенды-примеры-реализации">Микрофронтенды, примеры
реализации</h3>
<ul>
<li><strong>микрофронтенды как сквозные команды</strong>, например,
/albums, /bucket это две команды, и каждая отвечает за свою страницу и
полностью логику за этот сервис</li>
<li><strong>виджеты</strong> - каждая часть (блок) это отдельный сервис
и встраивается на страницу не зависимо, у каждого виджета свой API и
каждый реагирует на уведомление, типа произошел заказ в блоке “заказ” и
полетело уведомление произошел заказ, блок “корзина” отреагировал на это
уведомление</li>
</ul>
<h4 id="взаимодействие-front-с-backend">Взаимодействие front с
backend</h4>
<ul>
<li><p><strong>Плохая реализация</strong> - каждый front сервис делает
“одинаковый” запрос на backend и сам агрегирует данные</p></li>
<li><p><strong>Центральный шлюз</strong></p></li>
<li><p>собирает запросы от front сервисов и агрегирует данные,
объединяет похожие запросы в один шлюз</p></li>
</ul>
<h3 id="bff---backend-for-front">BFF - backend for front</h3>
<ul>
<li>для каждого front сервиса свой шлюз он же “backend for frontend”,
например, для IOS свой BFF, для Android свой BFF</li>
<li>один опыт один BFF. Однако если сильно расходятся, то лучше
раздельные BFF.</li>
</ul>
<blockquote>
<p>Абсолютно нормально если есть дублирование кода в BFF или в
микросервисах</p>
</blockquote>
<ul>
<li>похожий функционал можно также вынести в BFF (отдельная сущность,
BFF for BFF)
<ul>
<li>например, wish_list, который используют другие BFF,</li>
<li>при этом этот BFF делает только, что агрегирует запросы в backend,
касающиеся wish_list</li>
<li>делать такие BFF только при значительном объеме объединения</li>
</ul></li>
</ul>
<h3 id="graphql">GraphQL</h3>
<ul>
<li>язык запросовЮ позволяющий клиентам создавать запросы для доступа к
данным (динамически изменять запросы)</li>
<li>при этом нет необходимости реализовывать обработку запросов на
сервере для каждой сущности</li>
</ul>
<hr />
<h2 id="глава-15-организационные-структуры">Глава 15 Организационные
структуры</h2>
<ul>
<li>при переходе на микросервисы - НЕОБХОДИМО организовать структуру
компании
<ul>
<li>слабо связанные команды (функциональные/потоковые) могут:
<ul>
<li>вносить крупные изменения без разрешения и полагания какого-либо за
пределами команды</li>
<li>завершить, развертывать свою работу не координируясь с другими</li>
<li>тестировать не запрашивая интегрированной тестовой среды</li>
</ul></li>
</ul></li>
</ul>
<h3 id="закон-конвея">Закон Конвея</h3>
<ul>
<li>организация, разрабатывающая систему, неизбежно создает проект,
структура которого будет копией коммуникационной структуры
организации</li>
</ul>
<blockquote>
<p>Другое определение - “Если у вас есть четыре группы, работающие над
компилятором, вы получите четырехпроходной компилятор”</p>
</blockquote>
<h3 id="размер-команды">Размер команды</h3>
<ul>
<li>идеальный размер, чтобы накормить “одной пиццей”</li>
<li>5-10 человек</li>
<li>также можно выделить крупные компании из небольших команд
<ul>
<li>своя автономность, полномочие, ответственность</li>
</ul></li>
</ul>
<h3 id="общее-использование-сервиса">Общее использование сервиса</h3>
<ul>
<li>в идеале, один сервис одна команда</li>
<li>если одна другая команда только использует сервис, а он принадлежит
другой, нужно передать его команде, которая его использует</li>
<li>общее использование
<ul>
<li>общий фреймворк - содержит код для “команды А”, для “команды Б”,
каждая команда разворачивает только свою часть</li>
<li>библиотеки - одно ядро, но внутри библиотеки для каждой отдельной
команды, разворочается один сервис</li>
</ul></li>
</ul>
<h2 id="глава-16-эволюционный-архитектор">Глава 16 Эволюционный
архитектор</h2>
<h3 id="архитектура-по">Архитектура ПО</h3>
<ul>
<li>общее понимание проекта системы
<ul>
<li>система разделена:
<ul>
<li>как компоненты</li>
<li>как они взаимодействуют через интерфейсы</li>
</ul></li>
</ul></li>
</ul>
<h3 id="архитектор-как-градостроитель">Архитектор как
градостроитель</h3>
<ul>
<li>меньше беспокоится о происходящем внутри зоны (района)</li>
<li>больше о том, что происходит между зонами</li>
<li>создает API между сервисами. При таком, изменения внутри сервиса
производятся легко</li>
<li>сокрытие информации о сервисе в связке с открытыми интерфейсами</li>
</ul>
<blockquote>
<p>Правила предназначены для послушания глупцов и руководства
мудрецов</p>
</blockquote>
<h3 id="правила-архитектора">Правила архитектора</h3>
<ul>
<li>Методы проектирования
<ul>
<li>Rest/Http</li>
<li>Инкапсулировать устаревшее</li>
<li>маленькие независимые сервисы</li>
</ul></li>
<li>Архитектурные принципы
<ul>
<li>устранить случайные сложности</li>
<li>согласованные интерфейсы и потоки данных</li>
<li>нет универсального решения</li>
</ul></li>
<li>Стратегические цели
<ul>
<li>позволить бизнесу масштабироваться</li>
<li>поддержка входа на новые рынки</li>
</ul></li>
</ul>
<blockquote>
<p>Все микросервисы должны быть частью Одной системы Можно выносить,
получать данные мониторинга каждого сервиса в одно место (общее) Наличие
одного стандарта Хорошо, 2 и более Плохо</p>
</blockquote>
<h3 id="единые-правила-межсервисного-взаимодействия">Единые правила
межсе́рвисного взаимодействия</h3>
<ul>
<li>единые стандарты ответов (например, успешные 2хх, ошибка 4хх, ошибка
сервера 5хх)</li>
<li>неважно Http или другой протокол</li>
</ul>
<h3 id="документация">Документация</h3>
<ul>
<li>иметь примеры, шаблоны, хотя бы лучшее из частей системы, чтобы
можно не просто имитировать пример</li>
<li>хранить шаблоны, чтобы использовать часть кода из коробки (например,
для создания нового сервиса, его первоначальная настройка)</li>
</ul>
</body>
</html>
