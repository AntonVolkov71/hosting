<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Высоконагруженные приложения. Программирование, масштабирование, поддержка Клеппман Мартин.md</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Высоконагруженные приложения. Программирование,
масштабирование, поддержка Клеппман Мартин.md</h1>
</header>
<h1
id="высоконагруженные-приложения.-программирование-масштабирование-поддержка-клеппман-мартин">Высоконагруженные
приложения. Программирование, масштабирование, поддержка | Клеппман
Мартин</h1>
<h1 id="прочитана">Прочитана</h1>
<h2 id="часть-1-основы-информационных-система">Часть 1 Основы
информационных система</h2>
<h3
id="высоконагруженные-данными-приложения---data-intensive-applications---dia">Высоконагруженные
данными приложения - data intensive applications - DIA</h3>
<h3
id="высоконагруженные-вычисления---compute-intensive">Высоконагруженные
вычисления - compute intensive</h3>
<h3 id="надежность---reliability">Надежность - reliability</h3>
<h3 id="масштабируемость---scalability">Масштабируемость -
scalability</h3>
<h3 id="удобство-сопровождения---maintainability">Удобство сопровождения
- maintainability</h3>
<h3 id="разработка-состоит">Разработка состоит:</h3>
<ul>
<li><strong>Надежность - reliability</strong>
<ul>
<li>устойчивость к аппаратным и программным сбоям, человеческим
факторам</li>
<li>способность выдержать ошибочные действия пользователя</li>
<li>предотвращать не санкционный доступ или неправильную
эксплуатацию</li>
<li>работать нормально в случае проблем</li>
</ul></li>
<li><strong>Масштабируемость - scalability</strong>
<ul>
<li>показатели нагрузки и производительности, время ожидания, процент
или пропускная способность</li>
</ul></li>
<li><strong>Удобство сопровождения - maintainability</strong>
<ul>
<li>удобство эксплуатации, простота и возможность развития</li>
</ul></li>
</ul>
<h3 id="сбой-vs-отказ">Сбой vs Отказ</h3>
<ul>
<li>сбой - fault
<ul>
<li>отклонение одного из компонентов системы от рабочих
характеристик</li>
</ul></li>
<li>отказ - failure
<ul>
<li>система в целом прекращает предоставление сервиса &gt; Предотвратить
переход сбоев в отказ</li>
</ul></li>
<li>необходимо генерить сбои, чтобы добиться устойчивости - Хаос
инжиниринг</li>
</ul>
<h4 id="аппаратные-сбои">Аппаратные сбои</h4>
<ul>
<li>среднее время на отказ (mean time to failure, MTTF)
<ul>
<li>винчестер работает от 10 до 50 лет
<ul>
<li>если в кластере 10 000 винчестеров, примерно 1 отказ в день</li>
<li>решение - RAID массивы, дублирование и т.д.</li>
</ul></li>
</ul></li>
<li>применять методы устойчивости чем избыточность аппаратного
обеспечения</li>
</ul>
<h4 id="программные-сбои">Программные сбои</h4>
<ul>
<li>чтобы избежать, полезно:
<ul>
<li>всесторонние тесты</li>
<li>изоляция процессов</li>
<li>мониторинг</li>
<li>анализ поведения системы при эксплуатации</li>
<li>самопроверка внутри сервиса</li>
</ul></li>
</ul>
<h4 id="человеческий-фактор">Человеческий фактор</h4>
<ul>
<li>ошибки в конфигурации операторами</li>
<li>предоставить эксплуатации (операторам) песочницу для изучения и
экспериментирования с системой</li>
<li>тестирование на всех уровнях, автоматизированное тестирование с
пограничными случаями</li>
<li>обеспечить быстрое восстановление после выявления ошибок, откат
конфигурации</li>
<li>настроить явный мониторинг, метрики (телеметрия), что позволит
определить на ранней стадии нарушения</li>
</ul>
<h3 id="нагрузка">Нагрузка</h3>
<ul>
<li>нагрузку можно описать параметрами нагрузки, например:
<ul>
<li>количество запросов в секунду</li>
<li>отношение операция чтения к записи в БД</li>
<li>количество активных клиентов в чате</li>
</ul></li>
<li>бывает, что чтение чаше записи, тогда при таком лучше сразу писать
кеш при операции записи, чтобы при чтении не производить вычисления</li>
</ul>
<h3 id="описание-производительности">Описание Производительности</h3>
<ul>
<li>как измениться производительность системы если увеличить нагрузку, а
ресурсы системы не менять (CPU, RAM)</li>
<li>насколько нужно увеличить ресурсы при увеличении нагрузки, чтобы
производительность не уменьшалась</li>
</ul>
<h3 id="время-ожидания-vs-время-отклика">Время ожидания vs Время
отклика</h3>
<ul>
<li><strong>время ожидания - latency</strong>
<ul>
<li>длительность ожидания запроса обработки, время на протяжении
которого ожидает обслуживания</li>
</ul></li>
<li><strong>время отклика - response time</strong>
<ul>
<li>то, что видит клиент, помимо обработки запроса включает задержки
сети, сообщений в очереди</li>
<li>Параметр времени отклика:
<ul>
<li>арифметическое среднее (не самое лучшее), типа среднее время
запросов 400мс, хотя при этом может быть 200мс и 5 секунд(что не
допустимо)</li>
<li>процентили - среднее по разным показателям, например:
<ul>
<li>считаем в процентах запросы до 200мс и так далее, и выясняем
соотношение этих групп, каких больше</li>
<li>99% запросов менее 200мс, 1% больше секунды - на самом деле, 1%
может быть самыми ценными запросами</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="принципы-проектирования">Принципы проектирования</h3>
<ul>
<li>удобство эксплуатации - облегчение поддержки</li>
<li>простота - облегчает понимание системы новыми инженерами</li>
<li>возможность развития - упрощает внесение изменений в будущем,
адаптация
<ul>
<li>расширяемость - extensibility</li>
<li>модифицируемость - modifiability</li>
<li>пластичность - plasticity</li>
</ul></li>
</ul>
<h4 id="удобство-эксплуатации">Удобство эксплуатации</h4>
<ul>
<li>максимально автоматизировать, чтобы персонал отвечал только за:
<ul>
<li>мониторинг состояния системы и восстановления</li>
<li>выяснение причин проблем, отказов</li>
<li>поддержка актуального ПО</li>
<li>отслеживание влияния систем друг на друга</li>
<li>введение в эксплуатацию</li>
<li>перенос с одной системы на другую</li>
<li>поддержка безопасности</li>
</ul></li>
</ul>
<h4 id="простота">Простота</h4>
<ul>
<li>для исключения побочной сложности - лучше инструкция абстракций.
Хорошая абстракция позволяет скрыть большую часть реализации за
фасадом</li>
<li>многократное применение одного и того же хорошо</li>
</ul>
<h4 id="agile">Agile</h4>
<ul>
<li>паттерн рабочего процесса, обеспечивающий инфраструктуру адаптации к
изменениям</li>
</ul>
<h4 id="tdd">TDD</h4>
<ul>
<li>разработка через тестирование</li>
</ul>
<h4
id="evolvability---возможность-развития-адаптация-на-уровне-информационных-систем">Evolvability
- возможность развития (адаптация на уровне информационных систем)</h4>
<h3 id="требования-приложений">Требования приложений:</h3>
<ul>
<li>функциональные: хранение, извлечение, поиск, обработка</li>
<li>нефункциональные: безопасность, надежность, соответствие нормативным
документам, масштабируемость, удобство сопровождения</li>
</ul>
<h2 id="часть2-модели-данных-и-языки-запросов">Часть2 Модели данных и
языки запросов</h2>
<h4 id="rdbms">RDBMS</h4>
<ul>
<li>relation database management system - реляционные системы управления
базами данных</li>
</ul>
<h4
id="система-управления---information-management-system---ims">Система
управления - Information Management System - IMS</h4>
<h3 id="иерархические-модели">Иерархические модели:</h3>
<ul>
<li>реляционная SQL</li>
<li>сетевая модель “канула в лету”</li>
</ul>
<h3 id="sql">SQL</h3>
<ul>
<li>декларативный язык запросов</li>
<li>выполнить определенные операции в заданном порядке</li>
</ul>
<h3 id="mapreduce">MapReduce</h3>
<ul>
<li>модель программирования для обработки больших объектов данных
блоками на множестве машин</li>
<li>ни декларативный не императивный</li>
<li>состоит из map и reduce - должны быть чистыми (pure), используются
только передаваемые данные</li>
<li>основан на JavaScript функции</li>
</ul>
<h3 id="графоподобные-модели-данных">Графоподобные модели данных</h3>
<ul>
<li>вершины - vertices, узлы - node, или сущности - entity, состоит:
<ul>
<li>состоит из идентификатора, множества исходящих и входящих ребер</li>
</ul></li>
<li>ребра - edge, связи - relationship, или дуги - arc, состоит:
<ul>
<li>уникальный идентификатор</li>
<li>вершина с которой начинается (начальная)</li>
<li>вершина которой оно заканчивается (конечная)</li>
</ul></li>
</ul>
<h3 id="графовое-хранилище">Графовое хранилище:</h3>
<ul>
<li>из 2 реляционных таблиц:
<ul>
<li>вершины</li>
<li>ребра</li>
</ul></li>
</ul>
<h3 id="аспекты-графового-хранилища">Аспекты графового хранилища:</h3>
<ul>
<li>любая вершина может быть соединена ребром с любой другой
вершиной</li>
<li>для любой вершины можно найти входящие, исходящие ребра, выполнить
обход графа, найти путь по цепочке вершин в прямом и обратном
направлениях</li>
<li>в одном графе, задействуя разные виды связей можно хранить разные
виды информации</li>
</ul>
<h4 id="cypher">Cypher</h4>
<ul>
<li>декларативный язык запросов для графовых БД</li>
</ul>
<h3 id="тройные-кортеж">Тройные кортеж</h3>
<ul>
<li>[ субъект, предикат, объект] - (lucy, age, 33)</li>
<li>субъект
<ul>
<li>эквивалентен вершине графа</li>
</ul></li>
<li>объект
<ul>
<li>представляет одну из 2 вещей:
<ul>
<li>Значения простого типа данных (строка, число). При этом предикат и
объект эквивалентны ключу и значению свойства вершины объекта. Вершина
Lucy со свойствами {age: 33}</li>
<li>Другую вершину графа. Предикат здесь ребро графа, субъект начальная
вершина, объект конечная вершина
<ul>
<li>Lucy, marriedTo, alain</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="sparql">SPARQL</h4>
<ul>
<li>язык запросов для хранилищ тройных кортежей, использующих модель
данных RDF (protocol and RDF Query Language)</li>
</ul>
<h3 id="фундамент-datalog">Фундамент datalog</h3>
<ul>
<li>модель данных аналогична модели хранилищ тройных кортежей
<ul>
<li>пример, name (usa, “United States”).type(usa, country)</li>
<li>правило работает если системе удается найти соответствие для всех
предикатов справа от оператора</li>
<li>запрос, recursive(location, Name) :- name (Location, Name)</li>
</ul></li>
<li>используется в Datomic</li>
<li>синтаксис S-выражений</li>
<li>похож на Prolog</li>
<li>слова с большой буквы это переменные</li>
</ul>
<h3 id="нереляционные.-nosql">Нереляционные. NoSQL</h3>
<ul>
<li>отсутствие обязательной схемы для хранения данных
<ul>
<li>Документированные - данные в виде отдельных документов, связи между
ни редкие</li>
<li>Графовые (MongoDB) - предназначены для сценариев, в которых данные
могут быть связаны</li>
</ul></li>
</ul>
<h2 id="часть-3-подсистемы-хранения-и-извлечения-данных">Часть 3
Подсистемы хранения и извлечения данных</h2>
<pre><code>  Если вы поддреживаете в вещах порядок, значит вы просто слишком ленивы, чтобы их искать</code></pre>
<p>У БД есть две задачи: - сохранность при получении - предоставление
данных</p>
<p>Простой пример - вставка - db-set 12345 {“name”: “london”} - вставка
- db-set 42 {“name”: “Tula”} - получение - db-get 42 //{“name”:
“Tula”}</p>
<pre><code> #!bin/bash
 db-set(){
    echo &quot;$1,$2&quot; &gt;&gt; database
 }
 
 db-get(){
    grep &quot;^$1&quot;, database | sed-e &quot;s|^$1,||&quot; | tail -n 1
 }
 
 // вставить можно хоть JSON</code></pre>
<ul>
<li>в данном поиск - O(n), поэтому необходим индекс</li>
<li>текстовый файл, где данные (ключ, значение) разделены запятой</li>
<li>здесь поиск ключа с конца и до первого вхождения</li>
<li>данные добавляются в конец, это эффективно (у многих БД так)</li>
<li>этот файл и есть журнал последовательность записей, предназначенных
для добавления в конец данных
<ul>
<li>данные могут быть двоичные либо другие</li>
</ul></li>
</ul>
<h3 id="индекс">Индекс</h3>
<ul>
<li>дополнительная структура, производная от основных данных</li>
<li>идея в дополнительном хранении определенных метаданных как
указатели, помогающие найти данные</li>
<li>добавление индекса дорого</li>
<li>по умолчанию многие БД не индексируют, поэтому делаем руками!!</li>
</ul>
<blockquote>
<p>Индексы ускоряют чтение, замедляют запись</p>
</blockquote>
<h3 id="хеш-индекса">Хеш индекса</h3>
<ul>
<li>для простого примера, хранить Хеш карту, и класть/забирать данные
всегда из одного места</li>
</ul>
<h4 id="решение-исчерпания-места-на-диске">Решение исчерпания места на
диске</h4>
<ul>
<li>разбить журнал на сегменты определённого размера, закрывая файл при
достижении определенного размера, и записывать в новый файл</li>
<li>после можно выполнить <strong>Уплотнение</strong> (compaction)
<ul>
<li>отбрасывание дублирующих ключей (оставлять только последние
записи)</li>
<li>это лучше делать в отдельном потоке</li>
<li>можно слить несколько файлов и уплотнить</li>
</ul></li>
</ul>
<h4 id="формат-файлов">Формат файлов</h4>
<ul>
<li>CSV - не лучшее решение для журнала</li>
<li>Двоичный наиболее подходящее</li>
</ul>
<h4 id="удаление-записей">Удаление записей</h4>
<ul>
<li>на записи ставится отметка об удалении</li>
<li>при слиянии эта запись не засчитывается</li>
</ul>
<h4 id="восстановление-после-сбоя">Восстановление после сбоя</h4>
<ul>
<li>после перезапуска Хеш карта в оперативной памяти теряется, но можно
прочитать записи и по ключам восстановить Хеш карты</li>
<li>либо сохранить копии Хеш карт на диске</li>
</ul>
<h4 id="недописанные-записи">Недописанные записи</h4>
<ul>
<li>записывать контрольные суммы, при восстановлении можно обнаружить и
игнорировать поврежденные части журнала</li>
</ul>
<h4 id="управление-конкурентным-состоянием">Управление конкурентным
состоянием</h4>
<ul>
<li>запись строго в одном потоке</li>
<li>чтение параллельно</li>
</ul>
<h3 id="ss-таблица-и-lsm-деревья">SS-таблица и LSM-деревья</h3>
<ul>
<li>журналированное дерево слияния - log structured merge</li>
<li>sorted string table - данные отсортированны по ключу</li>
<li>каждый ключ встречается один раз в объединенном сегменте</li>
<li>метод слияния больших журналов выполняется просто и эффективно,
похож на сортировку слиянием</li>
<li>не нужно хранить индекс ключей, но храним индекс смещения
(разраженный)</li>
<li>для поддержания сортировки данных при записи используются деревья
(красно-черные VL-дерево)</li>
<li>храним дерево в оперативной памяти, если становится большим пишем на
диск в виде SS-таблицы
<ul>
<li>одна большая проблема, если происходит сбой, все данные из MemTable
- в оперативной памяти теряются</li>
<li>для этого параллельно можно использовать обычный журнал и писать
данные в него, для восстановления MemTable</li>
</ul></li>
</ul>
<h4 id="создание-lsm-дерева-из-ss-таблиц">Создание LSM дерева из
SS-таблиц</h4>
<ul>
<li>описывается алгоритм (выше который) используется в Level DN, Rocks
DB</li>
<li>одна из проблем отсутствие ключа, придется прочитать весь MemTable,
для этого используется Фильтр-Блума, позволяющий установить
встречающиеся ключи в БД</li>
<li>используется по уровневое уплотнение в соответствии с размером или
по слоям</li>
</ul>
<h4 id="b-деревья">B-деревья</h4>
<ul>
<li>индексная структура, используется до сих опр в реляционных и
нереляционных БД</li>
<li>как SS-таблицы хранят ключ-значение в отсортированных по ключу</li>
<li>БД разбивается на блоки или страницы фиксированного размера
(~4кб)</li>
<li>все страницы имеют адрес и могут ссылаться на другие аналогично
указателям</li>
<li>эти ссылки используются для создания дерева страниц</li>
<li>одна из страниц корень</li>
<li>количество ссылок на дочерние страницы на одной странице B-дерева -
это коэффициент ветвления (branching factor)
<ul>
<li>алгоритм сбалансированного дерева, обычная глубина 3-4 уровня</li>
</ul></li>
</ul>
<h4 id="надежность-b-дерева">Надежность B-дерева</h4>
<ul>
<li>для отказоустойчивости включают дополнительную структуру данных
<ul>
<li>журнал упреждающей записи (write head WAL), он же журнал повтора
(redo log)</li>
<li>в него добавляются только все модификации B-дерева до того как будет
применимо к страницам дерева</li>
</ul></li>
</ul>
<h4 id="усовершенствования-b-дерева">Усовершенствования B-дерева</h4>
<ul>
<li>использовать сохраненный ключ</li>
<li>использовать схему копирования при записи, измененная странице
записывается в другое место с созданием новых версий родительских
страниц</li>
</ul>
<blockquote>
<p>LSM быстрее при записи В-деревья быстрее при чтении НО!! все зависит
от нюансов конкретной системы</p>
</blockquote>
<h4 id="вторичный-индекс">Вторичный индекс</h4>
<ul>
<li>secondary index</li>
<li>можно создать несколько</li>
</ul>
<h4 id="сцепленный-индекс">Сцепленный индекс</h4>
<ul>
<li>concatenated index</li>
<li>объединяет несколько полей (один столбец к другому)</li>
<li>типа лоя поиска фамилия + имя</li>
<li>но бесполезен для поиска всех полей</li>
</ul>
<h4 id="нечеткий-индекс">Нечеткий индекс</h4>
<ul>
<li>поиск даже с учетом опечатки (вхождение с одним неправильным
символом)</li>
</ul>
<h3 id="бд-в-оперативной-памяти">БД в оперативной памяти</h3>
<ul>
<li>in memory datatable</li>
<li>при этом используется Rav на аккумуляторе?!</li>
<li>периодическая запись на диск, либо репликация на другие машины</li>
<li>при запуске загружается состояние с диска или других машин &gt;
Пример, БД Volt DB, MemSql, Oracle TimerTen</li>
</ul>
<h3 id="транзакции">Транзакции</h3>
<ul>
<li>обработка транзакций в реальном времени (online transaction
processing OLTP)</li>
<li>паттерн - приложение с помощью индекса ищет небольшое количество
данных по ключу. На основе вводимых данных сопоставляются или
обновляются данные</li>
<li>либо наоборот - online analytical processing (OLAP)
<ul>
<li>Аналитическая обработка данных в реальном времени, где огромное
количество просматриваемых данных и вычисляя сводные данные</li>
</ul></li>
</ul>
<h4 id="склад-данных">Склад данных</h4>
<ul>
<li>data warehouse - отдельные БД для аналитиков, копия данных только
для чтения</li>
<li>процесс помещения данных в склад “извлечение” - преобразование
загрузка (extract transform ETL)</li>
<li>чаще реляционные</li>
</ul>
<h4 id="схема-звезда">Схема звезда</h4>
<ul>
<li>star schema - моделирование с помощью измерений (dimensional
modeling)</li>
<li>одна таблица фактов, а остальные по разных таблицам</li>
<li>используется таблица фактов (отдельное событие)</li>
<li>ссылается на таблицу измерений</li>
</ul>
<h4 id="схема-снежинка">Схема снежинка</h4>
<ul>
<li>похожа на “звезду”, только измерения разбиваются на
подизмерения</li>
<li>в складе данных может быть до +100 столбцов</li>
<li>Select* - редко, обычно 4-5 столбцов, но большим количеством
строк</li>
</ul>
<h4 id="столбцовое-хранилище">Столбцовое хранилище</h4>
<ul>
<li>нужно хранить рядом все значения не из одной строки, а из одного
столбца</li>
<li>так можно использовать сжатие-кодирование с помощью битовой карты -
bitmap encoding</li>
</ul>
<h4 id="сортировка-в-столбцевом-хранилище">Сортировка в столбцевом
хранилище</h4>
<ul>
<li>можно сортировать по частому запросу (например, по дате)</li>
<li>сортировка по разным ключам и хранение в таком виде (разные
сортировки) на разных репликационных машинах (т.к. копии все равно
делаются)</li>
</ul>
<h4 id="запись-столбцевом-хранилище">Запись столбцевом хранилище</h4>
<ul>
<li>вначале обработка в оперативной памяти (вставка и поддержка
сортировки) только потом запись на диск</li>
</ul>
<h4 id="материализованное-представление">Материализованное
представление</h4>
<ul>
<li>materialized view - запросы с функцией агрегирования (count, SUM) и
записывать в кеш</li>
</ul>
<h2 id="часть-2-кодирование-и-эволюция">Часть 2 Кодирование и
эволюция</h2>
<ul>
<li>Возможность развития - evolvability</li>
<li>Плавающее обновление - rolling upgrade (поэтапное развертывание)
<ul>
<li>новая версия разворачивается на нескольких узлах и проверяется,
работает ли она без проблем</li>
<li>обратная совместимость - более новый код способен читать данные,
записанные старой версией</li>
<li>прямая совместимость - старый код способен читать данные, записанные
новой версией</li>
</ul></li>
</ul>
<h3 id="кодирование">Кодирование</h3>
<ul>
<li>преобразование из представления в памяти в последовательность байтов
или маршалинг (marshaling) или сериализация (serialization)</li>
<li>обратная операция - декодирование (decoding), парсинг (parsing),
десериализация, демаршалинг</li>
</ul>
<h4 id="библиотеки-двоичного-кодирования">Библиотеки двоичного
кодирования</h4>
<ul>
<li>Apache Thrift - Facebook (Binary protocol, Compact Protocol)</li>
<li>Protocol Buffers - Google</li>
</ul>
<blockquote>
<p>Compact protocol, Protocol Buffer - кодировка чисел разбивается на 2
байта - 1337 1|111001 0|00110100 -&gt; 9 Oa -&gt; 1337</p>
</blockquote>
<h4 id="avro">Avro</h4>
<ul>
<li>двоичный формат, содержит два языка описания схем
<ul>
<li>Avro IDL - для редактирования людьми</li>
<li>основанный на JSON - для считывания ПК</li>
</ul></li>
<li>схема для чтения и записи необязательно должны совпадать, достаточно
быть совместимы</li>
<li>при больших файлах, схема вставляется в начало файла (либо версию
схемы), а схему отдельно в БД - схема на весь документ</li>
</ul>
<h4 id="поток-данных-через-бд">Поток данных через БД</h4>
<ul>
<li>время жизни данных превышает время жизни кода</li>
</ul>
<h3 id="rest-api">REST &amp; API</h3>
<ul>
<li>клиентское приложение JS в браузере может задействовать
XMLHttpRequest - чтобы стать Http-клиентом - технология AJAX</li>
<li>Сервисно-ориентированная архитектура (service oriented architecture
SOA)
<ul>
<li>когда сервер есть клиент для других</li>
<li>в последнее время это называется микросервисная архитектура</li>
</ul></li>
</ul>
<h3 id="веб-сервисы">Веб сервисы</h3>
<ul>
<li>если в качестве базового протокола HTTP</li>
<li>REST
<ul>
<li>!! НЕ протокол, а подход к проектированию, основанный на принципах
Http (RestFull)</li>
<li>просто указать версию API в заголовках Accept</li>
</ul></li>
<li>SOAP
<ul>
<li>основан на XML</li>
<li>API SOAP - веб-сервис описанные языком описания веб-сервисов WSDL -
web services description language</li>
<li>код генерируется с помощью WSDL запроса</li>
</ul></li>
</ul>
<h3 id="rpc">RPC</h3>
<ul>
<li>remote procedure call - удаленный вызов процедур</li>
<li>идея, что запрос к удаленному сетевому сервису выглядит как вызов
функции или метода вне зависимости от расположения</li>
<li>МИНУСЫ
<ul>
<li>запрос может потеряться в сети (сбой)</li>
<li>учитывать, что запрос прошел, но на самом деле потерялся</li>
<li>учесть повторный вызов одной и той же операции (механизм
дедупликация - идемпотентности)</li>
<li>параметры нельзя передать как ссылки (указатели) на объект
(необходимо кодировать)</li>
<li>клиент и сервис могут быть на разных языках, что может привести к
проблемам, например, числа с плавающей точкой 2^53 в JS</li>
</ul></li>
<li>Фреймворки
<ul>
<li>Thrift, Avro - используют Protocol Buffers</li>
<li>Finagle, Rest.li - используют фьючерсы (futures) промисы</li>
</ul></li>
<li>gRPC
<ul>
<li>поддержка потока данных (stream)</li>
</ul></li>
</ul>
<h3 id="система-асинхронной-передачи-сообщений">Система асинхронной
передачи сообщений</h3>
<ul>
<li>запрос от клиента называется сообщением (message)</li>
<li>сообщения проходят не напрямую, а через посредника - брокера
сообщений (message broker) или очередь сообщений (message queue) или
промежуточное ПО, ориентированным на обработку сообщений (message -
oriented middleware)</li>
</ul>
<h3 id="брокеры-сообщений">Брокеры сообщений</h3>
<ul>
<li>TIBCO, WebSphere, webMethods (старое)</li>
<li>RabbitMQ, ActiveMQ, Apache Kafka</li>
</ul>
<h3 id="ииспользование-брокера-сообщений">ИИспользование брокера
сообщений</h3>
<ul>
<li>один процесс отправления сообщений для очереди или темы/дискуссии
(topic), а брокер обеспечивает доставку сообщений потребителям
(consumers) или подписчикам (subscribers)</li>
<li>в одной дискуссии может быть много инициализаторов (producers) и
много потребителей</li>
<li>можно использовать любой формат кодирования</li>
</ul>
<h4 id="акторная-модель-actor-model">Акторная модель (actor model)</h4>
<ul>
<li>модель программирования для создания конкурентного доступа в
пределах одного процесса</li>
<li>каждый актор соответствует одному клиенту ли сущности (может быть
свое локальное состояние)</li>
<li>один актор обрабатывает одно сообщение</li>
<li>допускается потеря сообщения в пределах одного процесса</li>
<li>фреймворки
<ul>
<li>Akka (Java)</li>
<li>Orleans</li>
<li>Erlang OTP - можно менять схемы записи</li>
</ul></li>
</ul>
<h2 id="часть-3-распределенные-данные">Часть 3 Распределенные
данные</h2>
<blockquote>
<p>В 1 части вопросы системы данных, актуальные при хранении данных на
отдельных машинах В 2 части извлечение и хранение на нескольких
машинах</p>
</blockquote>
<h3 id="масштабирование">Масштабирование</h3>
<ul>
<li>если объем данных, нагрузка по чтению и записи перерастает
возможности одной машины, то можно распределить на несколько машин</li>
<li>вертикальная
<ul>
<li>vertical scaling</li>
<li>увеличение мощности одной машины</li>
<li>использование как вариант архитектуры с раздельными дисковыми
накопителями
<ul>
<li>несколько машин, но данные на одном массиве</li>
</ul></li>
</ul></li>
<li>горизонтальная
<ul>
<li>horizontal scaling</li>
<li>архитектура без разделения ресурсов (shared nothing
architectures)</li>
<li>отдельная машина - это узел (node), свой CPU, диск, память</li>
<li>согласование на уровне ПО с помощью сети</li>
<li>можно рапрделеиять географически, для своего региона</li>
<li>требуется наибольшая осторожность при разработке</li>
</ul></li>
</ul>
<h3 id="способы-распределения-данных-по-нескольким-узлам">Способы
распределения данных по нескольким узлам</h3>
<ul>
<li>Репликация - копии одних и тех же данных, хранятся на нескольких
узлах
<ul>
<li>в случае отказа, часть узлов данных можно вытащить из других</li>
<li>горизонтальная масштабируемость для чтения</li>
</ul></li>
<li>Секционирование
<ul>
<li>разбиение данных на подмножества (секции partition) - разным узлам
можно подставить в соответствии различные секции - шардинг</li>
</ul></li>
</ul>
<h4 id="алгоритмы-репликации">Алгоритмы репликации</h4>
<ul>
<li>с одним ведущим узлом (single leader)</li>
<li>с несколькими ведущими узлами (multi leader)</li>
<li>без ведущего узла (leaderless)</li>
</ul>
<blockquote>
<p>Узлы, в которых хранятся копии БД, называются Репликами</p>
</blockquote>
<h5 id="проблемы-репликации">Проблемы репликации</h5>
<ul>
<li>гарантия одних и тех данных во всех репликах</li>
</ul>
<h4 id="решение-проблемы-гарантии">Решение проблемы гарантии:</h4>
<ul>
<li>репликация с ведущим узлом
<ul>
<li>одни ведущий, другие ведомые (followers)</li>
<li>когда ведущий записывает, он отправляет информацию всем followers в
качестве части журнала репликации или потока изменений</li>
</ul>
<pre><code>Запрос (чтение/запись) -&gt; Реплика ведущего узла -&gt; Изменение данных -&gt; реплика ведомых узлов 
                                                                  -&gt; реплика ведомых  узлов &lt;- только на чтение</code></pre>
<ul>
<li>Запросы на запись только в ведущем узле (PostgreSQL, muSql,
Espresso, RabbitMQ, Kafka)</li>
</ul></li>
</ul>
<h4 id="синхронизированные-и-асинхронные-реплики">Синхронизированные и
асинхронные реплики</h4>
<ul>
<li>Синхронные
<ul>
<li>ведущий узел ждет подтверждения изменений от ведомых, после отвечает
пользователю</li>
<li>копии гарантированно актуальны и согласованы, но если ведомый
недоступен, то запись прервется</li>
<li>решение в случае сбоя узла, перевести его в асинхронный режим
(полу-синхронная конфигурация - semi - synchronous)</li>
</ul></li>
<li>Асинхронные
<ul>
<li>ведущий узел Не ждет подтверждения от ведомых</li>
<li>при сбое ведущего - сохранность данных не гарантируется</li>
</ul></li>
</ul>
<h4 id="создание-нового-ведомого-узла">Создание нового ведомого
узла</h4>
<ul>
<li>Проблема
<ul>
<li>при копировании БД, записи идут постоянно. Как обеспечить
копирование без блокировки основной БД</li>
</ul></li>
<li>Решение
<ul>
<li>создать согласованный снимок состояния БД на определенный момент
времени без блокировки БД в основной БД
<ul>
<li>в многих БД есть резервная копирование - можно использовать это</li>
</ul></li>
<li>скопировать снимок состояния на ведомый узел</li>
<li>ведомый узел подключится к ведущему и запрашивает все изменения с
момента снимка, с определенной позиции журнала снимка состояния
регистрация номера транзакции в журнале - log sequence number</li>
<li>когда ведомый завершит обработку изменений, такое состояние
называется Наверстывание упущенного</li>
</ul></li>
</ul>
<h4 id="перебои-в-обслуживании">Перебои в обслуживании</h4>
<ul>
<li>цель, чтобы система продолжал работать при отказе отдельного
узла</li>
<li>отказ Ведомого
<ul>
<li>у него есть журнал последних транзакций, после перезагрузке нагоняет
упущенное от ведущего</li>
</ul></li>
<li>отказ Ведущего
<ul>
<li>необходимо повысить в звании один из ведомых узлов до ведущего</li>
<li>настроить клиентов на новый</li>
<li>настроить ведомые на нового ведущего</li>
<li>этот Процесс называется “Восстановление после отказа”
<ul>
<li>вручную или автоматизированно
<ul>
<li>установить отказ ведущего узла (питание, сеть)</li>
<li>выбрать нового ведущего (оптимально самая свежая реплика)</li>
<li>настроить систему на новый ведущий узел</li>
</ul></li>
</ul></li>
<li>НО!! есть опасности
<ul>
<li>старый ведущий может проснуться и так же быть ведущим (необходимо
настроить механизм отключения если 2 ведущих)</li>
<li>проблема нереплицированных последних данных</li>
</ul></li>
</ul></li>
</ul>
<h4 id="операторная-репликация">Операторная репликация</h4>
<ul>
<li>если с ведущего отсылать запросы SQL на ведомые, чтобы те делали те
же самые операции, то будут проблемы например с датой</li>
</ul>
<h4 id="перенос-журнала-упреждающей-записи-wal">Перенос журнала
упреждающей записи (WAL)</h4>
<ul>
<li>записывать журнал и передавать ведомым, а те создают точные копии
структур данных</li>
</ul>
<h4 id="логическая-построчная-журнальная-репликация">Логическая
(построчная) журнальная репликация</h4>
<ul>
<li>логический журнал - разные форматы журнала для репликации и
подсистем хранения</li>
</ul>
<h4 id="триггерная-репликация">Триггерная репликация</h4>
<ul>
<li>репликация подмножества данных либо БД одного и того же типа в БД
другого типа</li>
<li>репликация на уровне приложения</li>
<li>Триггеры позволяют регистрировать пользовательский код, запускаемый
при возникновении в БД события изменения данных
<ul>
<li>DataBus Oracle, Bucardo Postgres</li>
</ul></li>
<li>больше расходов и возможности ошибок</li>
</ul>
<h4 id="проблемы-задержки-репликации">Проблемы задержки репликации</h4>
<ul>
<li>синхронная - сбой если 1 узел отвалился</li>
<li>асинхронная - можно получить устаревшие данные от ведущего
<ul>
<li>необходимо дождаться согласованности между узлами</li>
<li>конечная согласованность (eventual consistency) - неоднозначное
время - от миллисекунд до минут</li>
</ul></li>
<li>Варианты решения
<ul>
<li>монотонное чтение - один пользователь может читать только с одной
репликации
<ul>
<li>если идет запись, то и запрос чтения с той репликации</li>
</ul></li>
</ul></li>
</ul>
<h4 id="репликация-с-несколькими-ведущими-узлами">Репликация с
несколькими ведущими узлами</h4>
<ul>
<li>multi leader replication</li>
<li>чаще используется когда несколько ЦОД, и в каждом по 1-му ведущему
узлу
<ul>
<li>BDR Postgres, Tungsten Replicator MySql, Couch DB</li>
</ul></li>
<li>необходимо решать конфликты записи (одна и та же запись на разных
БД)</li>
</ul>
<h4 id="совместное-редактирование">Совместное редактирование</h4>
<ul>
<li>realtime collaborative editing</li>
<li>не решает задачи репликации БД, но имеет много общего</li>
<li>используется блокировка, чтобы было по очереди редактирование</li>
<li>обычно блокировка одно нажатие клавиши</li>
<li>и тут же репликация всем (эквивалент один ведущий узел)</li>
<li>конфликт можно решить по времени, кто последний тот и прав
<ul>
<li>лучше предотвращать - один ведущий узел или синхронная операция</li>
<li>например, запись может быть с разных машин, а при одновременной
записи перенаправлять на один узел и использовать блокировку</li>
</ul></li>
</ul>
<h4 id="топологии-репликации-с-несколькими-ведущими-узлами">Топологии
репликации с несколькими ведущими узлами</h4>
<ul>
<li>каждый с каждым (наиболее подходящий)</li>
<li>звезда - один узел корневой и он всем передает (можно обобщенное
дерево)</li>
<li>кольцо - каждый узел получает и передает ровно от одного узла</li>
<li>Проблема кольца и звезды
<ul>
<li>при отказе одного оборвется поток сообщений</li>
</ul></li>
<li>Проблема каждый с каждым
<ul>
<li>ссылки могут быть быстрее других</li>
<li>одни сообщения реплик обгоняют других (состояние гонки)
<ul>
<li>можно получить ответ, но вопрос придет позже, типа ответ из
будущего</li>
</ul></li>
</ul></li>
</ul>
<h4 id="репликации-без-ведущего">Репликации без ведущего</h4>
<ul>
<li>Amazon использует систему Dynamo-&gt; Dynamo DB (а она уже с ведущим
узлом)
<ul>
<li>отсюда Dynamo подобные БД, Dynamo Style database</li>
</ul></li>
<li>при записи информация добавляется сразу всем репликам</li>
<li>если одна не дает, но 2 и более дадут ответ, клиент получит
подтверждение</li>
<li>при чтении запрос идет параллельно, чтобы не получить старые версии,
проверяется версия записи</li>
<li>параллельно идет процесс - противодействие энтропии
<ul>
<li>ANTI ENTROPY PROCESS
<ul>
<li>постоянный поиск различия между репликами и копирует не
достающее</li>
</ul></li>
</ul></li>
<li>если 2 из 3 не запишут, тогда активные данные выбираются по кворуму
<ul>
<li>подтверждение w узлами</li>
<li>опросить минимум r узлов</li>
<li>n всего узлов
<ul>
<li>w + r &gt; n, удовлетворение условного есть чтение, запись по
кворуму</li>
<li>показатель, сколько система может позволить себе недоступных
узлов</li>
<li>чтение и запись проверяется по значению кворума, то есть если w=3 из
n=5, r=3, то операция успешна
<ul>
<li>если меньше будет ошибка операции</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="отбраковка-конкурентных-операций-записи">Отбраковка конкурентных
операций записи</h4>
<ul>
<li>lost-write
<ul>
<li>выигрывает последний один из вариантов</li>
</ul></li>
<li>wins
<ul>
<li>добавлять метку даты -&gt; выбирается свежая, остальные
отбраковываются</li>
</ul></li>
<li>lww
<ul>
<li>не лучший вариант если важно не терять данные</li>
</ul></li>
</ul>
<h4 id="векторы-версий">Векторы версий</h4>
<ul>
<li>помимо номера версии данных, реплике присваивается версия реплики
при выполнении операции записи</li>
<li>набор векторов версий - называется вектором</li>
<li>самая интересная разновидность
<ul>
<li>конечный вектор версии - dotted version vector</li>
</ul></li>
<li>при ответе отдается вектор и номер версии данных</li>
</ul>
<p>-&gt; Векторные версии иногда показывают векторные часы (vector
clock), хотя это не одно и тоже</p>
<h3 id="секционирование---partitioning">Секционирование -
partitioning</h3>
<ul>
<li>умышленное разбиение большого набора данных</li>
<li>основная цель масштабируемость
<ul>
<li>разные секции разместить в различных узлах кластера
<ul>
<li>по многим жестким дискам</li>
</ul></li>
</ul></li>
<li>Teradata, Tandom NonStop SQL</li>
<li>копий секций как и реплики хранят на разных узлах</li>
<li>цель секционирования
<ul>
<li>равномерно распределять по узлам данные и загрузку запросов</li>
<li>если части секции неравномерные -&gt; асимметричные
<ul>
<li>наличие асимметрии снижает эффективность (skewed)</li>
<li>такая ситуация называется “горячей точкой” - “hot spot”</li>
</ul></li>
</ul></li>
<li>один из методов секционирования</li>
<li>назначить непрерывный диапазон значений ключа (от мин до макс) на
каждую секцию, подобно бумажной энциклопедии
<ul>
<li>могут быть разной величины, например
<ul>
<li>от Антона до Бориса (где имя ключ), от Бориса до Вячеслав</li>
</ul></li>
<li>может использоваться хеш ключа</li>
<li>в Java Object.hasCode() - могут возвращать различные значения ключа
в разных процессах</li>
<li>!! при таком смежные ключи будут разбросаны по разным секциям</li>
<li>если ключ горячий, то простейшее решение
<ul>
<li>добавление в начало или конец случайного числа, чтобы разбить по
разным секциям
<ul>
<li>только для не большого количества ключей, ио это затратно</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="вторичные-индексы">Вторичные индексы</h4>
<ul>
<li>поиск вхождений - “найти все действия пользователя 123”</li>
<li>Sole, Elasticsearch</li>
<li>2 подхода
<ul>
<li>секционирование по документам - document-based partitioning</li>
<li>секционирование по термам - term-based partitioning</li>
</ul></li>
</ul>
<p>-&gt; Перебалансировка - rebalancing - процесс перемещения нагрузки с
одного узла в кластер на другой</p>
<h4 id="методики-перебалансировки">Методики перебалансировки</h4>
<ul>
<li>ПЛОХО
<ul>
<li>хеширование по модулю
<ul>
<li>суть, плохо для хеша mod N</li>
<li>частые перемещения ключей из-за роста N узлов</li>
</ul></li>
</ul></li>
<li>Фиксированное количество секций
<ul>
<li>задать сразу фиксированное количество (1000) и распределять по узлам
(10) 100 на узел
<ul>
<li>при добавлении узла заимствует по несколько секций, пока секции не
станут равномерными</li>
</ul></li>
</ul></li>
<li>Динамическое секционирование
<ul>
<li>при неправильном задании количества секций (фиксированно), можно
получить все данные в одной секции</li>
<li>HBase, RethinkDB</li>
<li>когда размер секции перерастает данные, он разбивает на 2
секции</li>
<li>и наоборот, если значительное количество данных удаляется, секцию
сливают с соседней (аналог в B-деревьях)</li>
<li>получается, в самом начале данных нет, создаем одну секцию,
<ul>
<li>при таком другие узлы простаивают</li>
<li>для этого делают предварительное разбиение (pre-splitting)</li>
</ul></li>
</ul></li>
</ul>
<h4 id="маршрутизация-запросов">Маршрутизация запросов</h4>
<ul>
<li>как клиент знает к какому узлу нужно подключится
<ul>
<li>обнаружение сервисов (service-discovery)</li>
</ul></li>
</ul>
<h5 id="решение-проблемы-маршрутизации-запросов">Решение проблемы
маршрутизации запросов</h5>
<ul>
<li>разрешить клиенту обращаться к любому узлу
<ul>
<li>если ответ в секции на узле, тогда ответит, если нет перенаправит на
нужный узел</li>
</ul></li>
<li>направлять все запросы клиента сначала маршрутизаторному звену, а он
перенаправляет на нужный.
<ul>
<li>Само звено не обрабатывает запросы</li>
</ul></li>
<li>требовать, чтобы клиенты учитывать секционирование и распределение
по узлам</li>
</ul>
<p>-&gt; Во всех случаях проблема - откуда отвечающий за маршрутизацию
компонент знает об изменениях в распределении секций - используется
отдельный сервис координации, все злы регистрируются к нем и
поддерживается актуальные - при каждом изменении узла/секции оповещает
координационный сервис</p>
<h3 id="транзакции-1">Транзакции</h3>
<ul>
<li>первая БД, использовавшая транзакции System R</li>
<li>ACID
<ul>
<li>atomicity, consistency, isolation, durability</li>
<li>атомарность, согласованность, изоляция, сохраняемость</li>
<li>термин более маркетинговый</li>
</ul></li>
<li>системы, которые не соответствуют ACID, называются BASE
<ul>
<li>как правило доступа Basically consistency</li>
</ul></li>
</ul>
<h4 id="атомарность-acid">Атомарность ACID</h4>
<ul>
<li>нет возможности разбиения на меньшие части</li>
<li>описывает происходящее при сбое
<ul>
<li>операции сгруппированные в атомарные транзакции, если не удается
завершить, то она прерывается</li>
<li>после отката транзакции можно быть уверенным, что данные не
записались и можно откатить</li>
</ul></li>
<li>атомарность == Прерываемость</li>
</ul>
<h4 id="согласованность-acid">Согласованность ACID</h4>
<ul>
<li>БД с точки зрения ПО находится в хорошем состоянии</li>
</ul>
<p>-&gt; Атомарность, изоляция и сохраняемость СВОЙСТВО БД -&gt;
Согласованность - свойство ПО</p>
<h4 id="изоляция-acid">Изоляция ACID</h4>
<ul>
<li>исключение состояния гонки - фиксации транзакций, последовательное
выполнение</li>
</ul>
<h3 id="обработка-ошибок">Обработка ошибок</h3>
<ul>
<li>БД ACID скорее отменит транзакцию, чем оставит ее незавершенной</li>
<li>либо запишет лучшее из возможного, а восстановление после ошибок
является обязанностью приложения</li>
<li>многие ПО просто дают ошибку, а не делают повтор транзакции
<ul>
<li>боятся дубляжа транзакции, (при успехе ответ может не дойти
обратно)</li>
</ul></li>
<li>полезна двухфазная фиксация транзакции (2PC)</li>
</ul>
<h3 id="изоляция">Изоляция</h3>
<ul>
<li>изоляция равно конкурентность</li>
<li>многие БД ACID применяют слабую изоляцию</li>
<li>Базовый уровень
<ul>
<li>чтение/перезапись зафиксированных данных</li>
<li>если одна транзакция записала данные, но не зафиксировала, а другая
транзакция увидела эти данные,
<ul>
<li>такая операция считается “грязной” (distired)
<ul>
<li>один записывает значение 3 (было 2), но еще не зафиксировало,</li>
<li>а другой читает эти данные, то он должен получить 2, пока запись 3
не зафиксируется</li>
</ul></li>
</ul></li>
<li>чтение зафиксированных данных Популярная уровень изоляции
<ul>
<li>Oracle, PostgresQl, MemSql</li>
</ul></li>
<li>делается блокировка на объект, только одна транзакция может
удерживать блокировку конкретного объекта</li>
</ul></li>
</ul>
<p>-&gt; Асимметрия в ACID - означает аномалию хронометража</p>
<h4 id="изоляция-снимков-состояния">Изоляция снимков состояния</h4>
<ul>
<li>каждая транзакция читает данные из согласованного снимка
состояния</li>
<li>чтение никогда не блокирует запись</li>
<li>запись никогда не блокирует чтение</li>
<li>БД хранит несколько зафиксированных версий объекта</li>
<li>многоверсионное управление конкурентным доступом (multiversion
concurrency control MVCC)</li>
<li>достаточно для изоляции уровня чтения 2 версии объекта:
<ul>
<li>зафиксировать и перезаписывающая</li>
<li>не зафиксированная</li>
</ul></li>
<li>называется по разному
<ul>
<li>Oracle - уровень сериализация (serializable)</li>
<li>Postgres, MySQL - воспроизводимое чтение (repeatable read)</li>
</ul></li>
</ul>
<h3 id="конфликты-между-транзакциями">Конфликты между транзакциями</h3>
<ul>
<li>проблема потерянного обновления (lost update)
<ul>
<li>конкурентное увеличение счетчика двумя пользователями</li>
</ul></li>
<li>атомарная операция
<ul>
<li>блокировка объекта при чтении, чтобы другие не могли прочитать до
фиксации изменений</li>
<li>это чтение по установленному курсу (cursor control)</li>
</ul></li>
<li>либо все атомарные операции выполнить в отдельном потоке</li>
<li>явная блокировка объекта, следующая транзакция после завершения
блокировки (чтение, изменение, запись)</li>
</ul>
<pre><code>begin TRANSACTION
SELECT * from figures
WHERE name=&#39;robot&#39; AND game_id=222 FOR UPDATE
UPDATE figures SET position=&#39;c u&#39; WHERE is=123
COMMIT;</code></pre>
<ul>
<li>for update блокирует все измененные запросом строки (!! можно забыть
про него)</li>
<li>обнаружение потерянных обновлений
<ul>
<li>типа если забыли установить в коде блокировку, или задействовали
атомарные операции</li>
</ul></li>
</ul>
<h4 id="асимметрия-записи-wrike-skew">Асимметрия записи (wrike
skew)</h4>
<ul>
<li>изменить данные точно по какому-то условию исходя из данных таблицы,
но это условие не блокирует действие конкурентной записи</li>
</ul>
<h4 id="фантомы">Фантомы</h4>
<ul>
<li>эффект, при котором операция записи в одной транзакции меняет
результат запроса на поиск другой</li>
</ul>
<blockquote>
<p>Проблема асимметрии и фантомов в отсутствие объекта, который можно
было бы заблокировать можно использовать созданный объект для блокировки
например, вынести отрезки времени брони в отдельную таблицу и
блокировать эти строки при изменении сама доп таблица не служит для
хранения, просто набор блокировок это называется Материализацией
Конфликтов (materializing conflicts)</p>
</blockquote>
<h4 id="сериализуемость---serializability">Сериализуемость -
Serializability</h4>
<ul>
<li>самый сильный уровень изоляции</li>
<li>предотвращает все возможные состояния гонки</li>
<li>использует
<ul>
<li>последовательное выполнение транзакции</li>
<li>2х фазная блокировка</li>
<li>метод оптимистического управления конкурентным состоянием</li>
</ul></li>
</ul>
<h4 id="последовательное-выполнение">Последовательное выполнение</h4>
<ul>
<li>простой способ проблем с конкурентным доступом
<ul>
<li>отказаться от него однопоточный цикл выполнения транзакции
<ul>
<li>RAM стала дешевле</li>
<li>OLTP транзакции короткие</li>
</ul></li>
<li>VOLT DB/H Store, Redis Datamic</li>
</ul></li>
</ul>
<h4 id="инкапсуляция-транзакций-в-хранимых-процедурах">Инкапсуляция
транзакций в хранимых процедурах</h4>
<ul>
<li>Store procedure</li>
<li>хранимая процедура отправляется код в транзакцию в БД, выполняется
быстро</li>
<li>Pl/pg SQL Postgres, PL/SQL Oracle</li>
</ul>
<h4 id="секционирование">Секционирование</h4>
<ul>
<li>для масштабирования на несколько ядер CPU можно секционировать
данные</li>
</ul>
<h4 id="х-фазная-блокировка-2pl">2х фазная блокировка (2PL)</h4>
<ul>
<li>А читает объект, В хочет записать, то В ждет фиксации или прерывания
транзакции А</li>
<li>А записывает объект, В хочет прочитать, то В ждет фиксации или
прерывания</li>
<li>реализация
<ul>
<li>СУБД MqSql, SQL Server DB2</li>
<li>1ая блокировка во время транзакции</li>
<li>2ая блокировка в конце выполнения транзакции (освобождение)</li>
<li>часто А ждет снятия блокировки транзакции В и на
<ul>
<li>взаимная блокировка</li>
<li>БД автоматически обнаруживает, чтобы остальные могли продолжить
работать</li>
</ul></li>
</ul></li>
</ul>
<h4 id="предикатные-блокировки">Предикатные блокировки</h4>
<ul>
<li>если уже установлены монопольные блокировки, а текущая транзакция
хочет установить предикатные блокировки, она ждет освобождение
монопольной блокировки</li>
<li>проверяется перед вставкой, обновление или удаление объекта
показывает новые или старые значения по условию существующей версии
блокировки</li>
<li>учитывается даже те объекты, которые еще нет (будущие)</li>
<li>!! но это все занимает много времени</li>
</ul>
<h4 id="блокировка-по-диапазону-значений-индекса">Блокировка по
диапазону значений индекса</h4>
<ul>
<li>большинство БД c 2PL реализуют по диапазону индекса index-range-lock
<ul>
<li>она же блокировка следующего ключа (next-key-locking)</li>
</ul></li>
<li>если подходящего индекса для блокировки нет, БД заблокирует всю
таблицу</li>
</ul>
<h4 id="сериализуемая-изоляция-снимков-состояния">Сериализуемая изоляция
снимков состояния</h4>
<ul>
<li>2х фазная блокировка - тормозит, но более надежная</li>
<li>слабые уровни изоляции - высокая производительность, но состояние
гонки</li>
<li>взаимоисключающие блокировки (mutually exclusive )</li>
<li>используется оптимистический подход
<ul>
<li>вместо блокировки, транзакция выполняется в надежде, что будет
хорошо.
<ul>
<li>При фиксации БД проверяет не нарушена ли изоляция, если да
транзакция отменяется и повторяется</li>
</ul></li>
<li>при этом производительность не высокая, из-за большого количества
прерываний транзакций</li>
</ul></li>
</ul>
<h4 id="проблемы-распределенных-систем">Проблемы распределенных
систем</h4>
<ul>
<li>частичный отказ - partition failure - часть системы могут перестать
работать совершенно не предсказуемо</li>
<li>определить отказы между узлами (по сети, по питанию), записями и не
вернувшимися ответами ! Невозможно.
<ul>
<li>есть разные ситуации, живой, но задержка ответа по сети</li>
<li>обычно способ, выставить определенное время ожидания ответа (если
превышает, значит ответ не будет получен)</li>
</ul></li>
</ul>
<h4 id="обнаружение-сбоев">Обнаружение сбоев</h4>
<ul>
<li>автоматическое обнаружение сбойных узлов</li>
<li>балансировщик нагрузки должен предотвращать запросы узлов, которые
не отвечают (выводить их из эксплуатации)</li>
<li>оператор уничтожил узел, а операционная система узла все равно
функционирует
<ul>
<li>необходимо оповещение другим узлам о прекращении работы выключенного
узла</li>
</ul></li>
</ul>
<h4 id="время-ожидания-и-неограниченные-задержки">Время ожидания и
неограниченные задержки</h4>
<ul>
<li>большое время - клиент будет видеть долго ошибку
<ul>
<li>короткое время -
<ul>
<li>быстрее обнаруживать сбои, но риск ошибочного объявления узла
вышедшим из строя</li>
<li>при объявлении неработающим узла,
<ul>
<li>запрос передается другому, но если объявлен по ошибке, запросы будут
выполняться 2 раза</li>
<li>обязанности этого узла необходимо делегировать на другие узды, при
этом увеличиться их нагрузка и на сеть</li>
</ul></li>
<li>узел может просто тормозить из-за пика, а его сочтут неработающим, и
его
<ul>
<li>нагрузка уйдет другим, что будет еще хуже, минус один узел</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>Передача одновременно пакетов одному узлу через сеть выполняется по
очереди на уровне командира TCP - при не доставке пакетов, отправляет
заново, для клиента это факт заметен только задержкой UDP - не
отправляет повторно, просто теряет данные, на зато идет передача (видео,
аудио) - Время ожидания подбирается экспериментально - система может
измерить время отклика и его разброс (jitter - фазовое дрожание),
автоматически подстраивается - PhiAccrual - узел, часы которого
расходятся слишком сильно с часами остального, следует объявить
неработоспособным - узел с отстающими часам неспособные перезаписать
значения, записанные ранее со спешащими часами - LWW - не способна
различить в таком случае, кто первый - решение Вектор Версий</p>
</blockquote>
<h3 id="garbage-collector---сборщик-мусора">Garbage collector - сборщик
мусора</h3>
<ul>
<li>suspend - приостановка</li>
<li>resume - возобновление</li>
<li>Java - выполняет отложенную загрузку файлов при первом
использовании, которая может произойти в любой момент,
<ul>
<li>что может приостановить ПО</li>
</ul></li>
</ul>
<blockquote>
<p>Приложения у которых есть жесткий дедлок отклика, при не укладывании
в срок, хранятся всей системой Системы жесткого реального времени - HARD
REAL-TIME SYSTEMS</p>
</blockquote>
<h4 id="кворум">Кворум</h4>
<ul>
<li>решение большинства узлов, дохлый ли узел, который не посылает
ответов (при этом этот узел принимает и отдает ответ, но они не
доходят)</li>
</ul>
<h3 id="сервис-блокировки-zoo-keeper">Сервис блокировки Zoo Keeper</h3>
<ul>
<li>устанавливается блокировки и дает ограждающие маркеры
<ul>
<li>1 узел получил блокировку на запись, но узел на паузу (сборщик
мусора например),
<ul>
<li>в это время 2 узел взял блокировку и записал, и тут 1 очухался и
зная, что у него блокировка, также записал, Но уде испортил данные</li>
</ul></li>
<li>для этого и нужны маркеры (нарастающие) если 1 узел решил дописать,
но у него маркер ниже, ему откажут</li>
</ul></li>
</ul>
<h4 id="узел-ненадежен-но-добропорядочен">Узел ненадежен, но
добропорядочен</h4>
<ul>
<li>может сбоить, но говорит правду</li>
<li>если узел врет/посылает поврежденные данные, то такое поведение -
византийский сбой
<ul>
<li>задача византийских генералов</li>
</ul></li>
</ul>
<h4 id="одноранговые-сети">Одноранговые сети</h4>
<ul>
<li>Bitcoin, blockchain</li>
<li>можно рассматривать как способ для не доверяющих друг другу
<ul>
<li>стороны договариваются, не пологая на какой-либо центральный
орган</li>
</ul></li>
<li>Web-приложения подверженны SQL-инъекциям или межсайтового выполнения
сценария - cross-site-scripting</li>
<li>Слабая форма лжи
<ul>
<li>некорректные сообщения вследствие аппаратных проблем</li>
</ul></li>
</ul>
<h3 id="модели-систем">Модели систем</h3>
<ul>
<li>это алгоритмы для решения задач распределенных систем</li>
<li>Синхронная
<ul>
<li>предполагает ограниченность сетевых задержек, пауз, и расхождения
часов</li>
</ul></li>
<li>Частично синхронная
<ul>
<li>большую часть времени система ведет себя как синхронная, но иногда
выходит за рамки длительности</li>
</ul></li>
<li>Асинхронная
<ul>
<li>нет права строить временные допущения</li>
</ul></li>
<li>Отказ
<ul>
<li>остановка узла сразу приводит к фатальному сбою</li>
</ul></li>
<li>Отказ-восстановление
<ul>
<li>отказ узла может произойти в любой момент, данные при этом не
теряются</li>
<li>Византийские сбои (произвольные)
<ul>
<li>узлы могут делать что угодно</li>
</ul></li>
</ul></li>
</ul>
<h3 id="корректность-алгоритмов">Корректность алгоритмов</h3>
<ul>
<li>например, правила сортировки, элемент слева меньше чем элемент
справа</li>
<li>Функциональная безопасность
<ul>
<li>ничего плохого не произошло
<ul>
<li>относиться у уникальности и монотонному возрастанию значений</li>
</ul></li>
</ul></li>
<li>Живучесть
<ul>
<li>относится к доступности</li>
<li>конечная согласованность со временем случится что-то плохое</li>
</ul></li>
</ul>
<h3 id="согласованность-и-консенсус">Согласованность и консенсус</h3>
<blockquote>
<p>Что лучше быть неправым и живым. Или правым, но мертвым?! - Консенсус
- согласованность между всеми узлами по какому-либо вопросу -
Линеаризуемость - самая сильная модель согласованности общего назначения
- идея - создать у пользователя иллюзию, что существует только одна
реплика - называется атомарная согласованность, сильная согласованность
- внешне система выглядит так, как если бы в ней была только одна копия
данных и все операции атомарны Линеаризуемость есть гарантия
актуальности - тонкость такой системы есть глобальные часы - если
операция чтения вернет новое значение, все последующие операции чтения
должны возвращать новое значение - для этого используется реестр
(обычный) - операция атомарного сравнения с измененным значением - нет
изоляции транзакций</p>
</blockquote>
<h4 id="линеаризуемость-и-не-сериализуемость">Линеаризуемость и Не
Сериализуемость</h4>
<ul>
<li>Сериализуемость
<ul>
<li>свойство изоляции транзакций, при которой каждая транзакция может
читать и записывать несколько объектов</li>
</ul></li>
<li>Линеаризуемость
<ul>
<li>гарантия возврата при чтении и записи реестра (отдельного объекта).
Не объединяет операции в транзакции</li>
</ul></li>
<li>но оба могут использоваться одновременно</li>
<li>такое состояние - строгая сериализуемость (сильная) &gt; Репликации
с несколькими ведущими узлами 0 НЕ Линеаризуемы!! &gt; Репликация без
ведущего - не всегда линеаризуема, зависит от конфигурации кворума</li>
</ul>
<h3 id="pc-2х-фазная-фиксация">2PC 2х фазная фиксация</h3>
<ul>
<li>фиксация транзакции по успешному ответу других узлов</li>
<li>!! зафиксированную транзакцию нельзя откатить</li>
<li>Используется координатор (диспетчер транзакций)
<ul>
<li>отправляет каждому узлу, спрашивая может ли они выполнить фиксацию и
отправляет все запрос фиксации</li>
</ul></li>
<li>Не путать с 2PL - сериализуемая изоляция</li>
</ul>
<h4 id="х-фазная-фиксация-3pc">3х фазная фиксация 3PC</h4>
<ul>
<li>three-phase-commit</li>
<li>предполагает наличие сети с ограниченной задержкой и узлами с
ограниченным откликом</li>
<li>Внутренние распределенные транзакции БД
<ul>
<li>поддержка внутренней транзакции между узлами БД</li>
</ul></li>
<li>Гетерогенные распределенные транзакции
<ul>
<li>две БД разных производителей, или вообще без БД, брокеры</li>
<li>сложнее чем внутренние</li>
</ul></li>
<li>XA-транзакции
<ul>
<li>X/open XA (extended Architecture)
<ul>
<li>стандарт 2х фазной фиксации в гетерогенных технологиях (1991
год)</li>
</ul></li>
</ul></li>
<li>отказоустойчивые консенсусные алгоритмы
<ul>
<li>View stamped Replication</li>
<li>Paxos</li>
<li>Raft, Zab</li>
<li>основная идея несколько циклов консенсуса</li>
</ul></li>
</ul>
<h3
id="системы-хранения-и-обработки-информации-с-группировкой-на-категории">Системы
хранения и обработки информации с группировкой на категории:</h3>
<ul>
<li>Системы записи
<ul>
<li>источник правды данных, в начале заполняется сюда</li>
</ul></li>
<li>Произвольные информационные системы
<ul>
<li>здесь данные являются результатом получения от неких уже
существующих данных другой системы (типа кеш)</li>
<li>дублируют (избыточные), но удобны для обеспечения скорости чтения
(денормализованы)</li>
</ul></li>
</ul>
<blockquote>
<p>Различие между системой записи и производной зависит не от
инструментов, а от того как вы применяете его. База всего лишь
инструмент</p>
</blockquote>
<h2 id="пакетная-обработка">Пакетная обработка</h2>
<ul>
<li>Сервисы (онлайн системы)
<ul>
<li>ожидают запросов и инструкций, поступающих от клиента.</li>
<li>Запрос отклик.</li>
<li>Пользователь жде ответа</li>
</ul></li>
<li>Системы пакетной обработки (автономные системы)
<ul>
<li>принимают большое количество данных</li>
<li>запускают задачу для их обработки и выдает данне, но вычисление этих
задач происходит долго</li>
<li>пользователь ждет ответа</li>
<li>запуск по расписанию</li>
<li>главная мера производительности - пропускная способность</li>
</ul></li>
<li>Системы поточной обработки (системы реального времени)
<ul>
<li>среднее между онлайновой и пакетной (автономной)</li>
<li>принимают данные на вход и генерируют выходные данные (не отвечает
на запросы)</li>
<li>но реализует на события</li>
</ul></li>
</ul>
<h3 id="алгоритм-пакетной-обработки">Алгоритм пакетной обработки</h3>
<ul>
<li>MapReduce -&gt; Hadoop, CouchDb, MongoDb
<ul>
<li>низкоуровневая модель &gt; Идея объединения программ в конвейер
стала частью того, что теперь известно как Философия Unix &gt; каждая
программа делает, что-то одно, и делает это хорошо &gt; пусть выходные
данные каждой программы станут входными данными другой программы (пока
неизвестной) &gt; не засоряйте вывод посторонней информацией &gt;
избегайте жестких табличных и двоичных форматов &gt; тестируйте как
можно раньше &gt; единый формат, Но для разных платформ</li>
</ul></li>
</ul>
<h4 id="mapreduce-1">Mapreduce</h4>
<ul>
<li>неизменные входные данные, не имеет побочных эффектов</li>
<li>только генерация выходных</li>
<li>среда разработки, позволяющаяся писать код для обработки больших
наборов данных в распределенной файловой среде</li>
<li>для создания задачи Mapreduce, необходимо реализации 2 функций
обратного вызова
<ul>
<li>Сопоставление - извлечь ключ и значение</li>
<li>Сжатие - принимает пары ключ-значение, создает Сопоставление и
объединение всех значений, может создавать выходные записи</li>
</ul></li>
<li>Mapreduce - это алгоритм обработки</li>
<li>Hadoop - это уже система, использующая Mapreduce</li>
</ul>
<h4 id="hadoopmapreduce">HadoopMapReduce</h4>
<ul>
<li>распределенные файловые системы HDFS &gt; Есть и другие
распределенные файловые системы: GlusterFS, QuantcostFileSystem (QFS),
сервисы хранения объектов AmazonS3, Asure Blob</li>
<li>в основе HDFS -&gt; Hadoop Distributes File System
<ul>
<li>ничего общего</li>
<li>центральный сервер (NameNode) - отслеживает на каком ПК хранятся те
или иные блоки данных</li>
<li>концептуально ОДна большая файловая система</li>
<li>файловые блоки дублируются на нескольких машинах
<ul>
<li>просто несколько копий</li>
<li>подобны RAID</li>
</ul></li>
</ul></li>
</ul>
<h3 id="потоковая-обработка">Потоковая обработка</h3>
<ul>
<li>пакетная обработка
<ul>
<li>технология, при которой считывается набор файлов в качестве входных
данных и затем создается новый набор в качестве выходных</li>
<li>входные данные конечны (ограничены)</li>
</ul></li>
<li>потоковая обработка
<ul>
<li>обработка событий по мере возникновения, обработка без разделения
времени (непрерывная)</li>
<li>публикация / подписка на поток</li>
</ul></li>
</ul>
<h3 id="брокеры-сообщений-1">Брокеры сообщений</h3>
<ul>
<li>вместо прямого обмена, при котором надо реализовывать обработку
сбоев</li>
<li>очередь соответственно своего рода БД</li>
<li>задача отправки и надежности на брокере</li>
<li>используется подтверждение обработки сообщения от клиента</li>
<li>удаляет запросы после доставки потребителю &gt; Событие - запись о
том, что произошло в некий момент времени &gt; CQRS - command query
responsibility segregation, разделение ответственности на команды и
запросы (чтение и запись)</li>
</ul>
<h3 id="обработка-сложных-событий">Обработка сложных событий</h3>
<ul>
<li>complex event processing - CEP - технология для анализа потоков
событий, которая требует поиска по определённым шаблонам
<ul>
<li>Esper, INFOSphere, Apama, SQLstream</li>
</ul></li>
</ul>
<h3 id="аналитика-запросов">Аналитика запросов</h3>
<ul>
<li>анализ запросов
<ul>
<li>вычисление скользящего среднего значения</li>
<li>измерение частоты событий</li>
<li>алгоритмы
<ul>
<li>фильтр Bloom</li>
<li>HyperLog</li>
</ul></li>
<li>системы
<ul>
<li>ApacheStorm, Concord, Kafka Streams</li>
</ul></li>
</ul></li>
<li>поиск в потоках СМИ на
<ul>
<li>подписка новостных источники по теме</li>
<li>подписка на рассылку товара</li>
<li>индикация запросов</li>
</ul></li>
<li>типы временных окон
<ul>
<li>Падающее - постоянная длина 10:30:00 - 10:30:39</li>
<li>Прыгающее - фиксированная длина окна 4 минуты:
<ul>
<li>10:30:00 - 10:34:39 и 10:31:00 - 10:35:39</li>
<li>для этого надо реализовать падающее окно в 1 минуту, а затем
объединить</li>
</ul></li>
<li>Скользящее - все события, происходящие с некоторыми интервалами
между собой.
<ul>
<li>“5 минутное” с 10:03:00 - 10:08:00, но в отличие от прыгающего там
событие либо в один интервал либо в другой,
<ul>
<li>здесь может попасть во все интервалы, которые захватит</li>
</ul></li>
</ul></li>
<li>Окно сессии - нет фиксированной продолжительности
<ul>
<li>Множество событий для одного пользователя, близкие по времени друг к
другу</li>
<li>окно значений, когда пользователь не активен</li>
</ul></li>
</ul></li>
<li>Объединение потоков
<ul>
<li>Поток-поток - объединение окон
<ul>
<li>например, ввод поиска и переход по URL, учитываем качество поиска
(URL может не соответствовать поиску) и время между этими действиями,
<ul>
<li>так как браузер мог быть долго открыт и вбит поиск, а перехода по
URL не было</li>
</ul></li>
</ul></li>
<li>Поток-таблица - обогащение потока
<ul>
<li>поток событий активности, содержащих ID пользователя, а на выходе
поток событий активных, в которых идентификатор дополняется информацией
о его профиле
<ul>
<li>это называется обогащение события</li>
</ul></li>
<li>каждый раз запрашивать долго, из-за удаленного узла, можно сделать
копию БД локально и запрашивать изменения (подписать на них)</li>
</ul></li>
<li>Таблица-таблица
<ul>
<li>вместо перебора людей, которых отслеживает юзер и находить их
последние твиты,
<ul>
<li>лучше подписаться на этого пользователя и в кеш записывать твиты
типа копий входящие</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="для-предотвращения-дублирования-операций">Для предотвращения
дублирования операций</h4>
<ul>
<li>можно создать уникальные идентификаторы операций (UUID) - и сделать
скрытым полем в приложении</li>
<li>а получить его в Хеш всех полей формы</li>
</ul>
</body>
</html>
